{"version":3,"file":"aws.js","mappings":"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","sources":["webpack://k6-jslib-aws/./src/internal/client.ts","webpack://k6-jslib-aws/./src/internal/config.ts","webpack://k6-jslib-aws/./src/internal/constants.ts","webpack://k6-jslib-aws/./src/internal/error.ts","webpack://k6-jslib-aws/./src/internal/http.ts","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/utils.ts","webpack://k6-jslib-aws/./src/internal/sqs.ts","webpack://k6-jslib-aws/./node_modules/uuid/index.js","webpack://k6-jslib-aws/./node_modules/uuid/lib/bytesToUuid.js","webpack://k6-jslib-aws/./node_modules/uuid/lib/rng-browser.js","webpack://k6-jslib-aws/./node_modules/uuid/v1.js","webpack://k6-jslib-aws/./node_modules/uuid/v4.js","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/external commonjs \"k6/http\"","webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/./src/internal/kms.ts","webpack://k6-jslib-aws/./src/internal/s3.ts","webpack://k6-jslib-aws/./src/internal/secrets-manager.ts","webpack://k6-jslib-aws/./src/internal/ssm.ts"],"sourcesContent":["import { AWSConfig } from './config'\nimport { HTTPHeaders } from './http'\n\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n    awsConfig: AWSConfig\n    serviceName: string\n\n    private _host?: string\n\n    /**\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     * @param  {string} serviceName - name of the service to target.\n     * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n     */\n    constructor(awsConfig: AWSConfig, serviceName: string) {\n        this.awsConfig = awsConfig\n        this.serviceName = serviceName\n    }\n\n    /**\n     * Property computing the URL to send the requests to when interacting with\n     * the specific AWS service the child class implements the functionalities of.\n     */\n    public get host() {\n        if (this._host == undefined) {\n            return `${this.serviceName}.${this.awsConfig.region}.${this.awsConfig.endpoint}`\n        }\n        return this._host\n    }\n\n    public set host(host: string) {\n        this._host = host\n    }\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n    url: string\n    headers: HTTPHeaders\n}\n","import { HTTPScheme } from './http'\n\n/** Class holding an AWS connection information */\nexport class AWSConfig {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme} ['https']\n     */\n    scheme: HTTPScheme = 'https'\n\n    // FIXME: Should really be called \"host\" instead. When used\n    // with localstack we pass a complete host (hostname:port) here.\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string} ['amazonaws.com']\n     */\n    endpoint: string = 'amazonaws.com'\n\n    /**\n     * Create an AWSConfig.\n     *\n     * @param {AWSConfigOptions} options - configuration attributes to use when interacting with AWS' APIs\n     * @throws {InvalidArgumentException}\n     */\n    constructor(options: AWSConfigOptions) {\n        if (options.region === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS region; reason: should be a non empty string'\n            )\n        }\n\n        if (options.accessKeyId === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS access key ID; reason: should be a non empty string'\n            )\n        }\n\n        if (options.accessKeyId.length < 16 || options.accessKeyId.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${options.accessKeyId.length}`\n            )\n        }\n\n        if (options.secretAccessKey === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS secret access key; reason: should be a non empty string'\n            )\n        }\n\n        if (options.secretAccessKey.length < 16 || options.secretAccessKey.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: size should be between 16 and 128 characters, got ${options.secretAccessKey.length}`\n            )\n        }\n\n        this.region = options.region\n        this.accessKeyId = options.accessKeyId\n        this.secretAccessKey = options.secretAccessKey\n\n        if (options.sessionToken !== undefined) {\n            this.sessionToken = options.sessionToken\n        }\n\n        if (options.scheme !== undefined) {\n            this.scheme = options.scheme\n        }\n\n        if (options.endpoint !== undefined) {\n            this.endpoint = options.endpoint\n        }\n    }\n}\n\n/**\n * Interface representing AWSConfig options\n */\nexport interface AWSConfigOptions {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme}\n     */\n    scheme?: HTTPScheme\n\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string}\n     */\n    endpoint?: string\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n    constructor(message: string) {\n        super(message)\n    }\n}\n","/**\n * Standard Amazon AWS query parameter names\n */\nexport const AMZ_ALGORITHM_QUERY_PARAM = 'X-Amz-Algorithm'\nexport const AMZ_CREDENTIAL_QUERY_PARAM = 'X-Amz-Credential'\nexport const AMZ_DATE_QUERY_PARAM = 'X-Amz-Date'\nexport const AMZ_EXPIRES_QUERY_PARAM = 'X-Amz-Expires'\nexport const AMZ_SIGNATURE_QUERY_PARAM = 'X-Amz-Signature'\nexport const AMZ_SIGNED_HEADERS_QUERY_PARAM = 'X-Amz-SignedHeaders'\nexport const AMZ_TARGET_QUERY_PARAM = 'X-Amz-Target'\nexport const AMZ_TOKEN_QUERY_PARAM = 'X-Amz-Security-Token'\n\n/**\n * Standard Amazon AWS header names\n */\nexport const AMZ_CONTENT_SHA256_HEADER = 'x-amz-content-sha256'\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase()\nexport const AMZ_SIGNATURE_HEADER = AMZ_SIGNATURE_QUERY_PARAM.toLowerCase()\nexport const AMZ_TARGET_HEADER = AMZ_TARGET_QUERY_PARAM.toLowerCase()\nexport const AMZ_TOKEN_HEADER = AMZ_TOKEN_QUERY_PARAM.toLowerCase()\n\n/**\n * Common HTTP headers we rely on in the signing process\n */\nexport const AUTHORIZATION_HEADER = 'authorization'\nexport const DATE_HEADER = 'date'\n\n/**\n * Lists the headers that are generated as part of the signature process.\n */\nexport const GENERATED_HEADERS = [AUTHORIZATION_HEADER, AMZ_DATE_HEADER, DATE_HEADER]\nexport const HOST_HEADER = 'host'\n\n/**\n * Lists the headers that should never be included in the\n * request signature signature process.\n */\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n    authorization: true,\n    'cache-control': true,\n    connection: true,\n    expect: true,\n    from: true,\n    'keep-alive': true,\n    'max-forwards': true,\n    pragma: true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    'user-agent': true,\n    'x-amzn-trace-id': true,\n}\n\n/**\n * Signature specific constants included in the signing process\n */\nexport const KEY_TYPE_IDENTIFIER = 'aws4_request'\nexport const SIGNING_ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256'\n\n/**\n * Maximum time to live of a signed request in seconds: 7 days.\n */\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7\n\n/**\n * SHA256 hash of an empty string (so we don't waste cycles recomputing it)\n */\nexport const EMPTY_SHA256 = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n\n/**\n * SHA256 hash of the unsigned payload constant (so we don't waste cycles recomputing it)\n */\nexport const UNSIGNED_PAYLOAD_SHA256 =\n    '5a41b0751e4537c6ff868564ab44a4d4ecceec2ec5b1c5f74d97422968e04237'\n\nexport const UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'\n","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    /**\n     * Error code issued by the service (if any)\n     */\n    code?: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string?} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code?: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n","/**\n * Type representing HTTP schemes\n */\nexport type HTTPScheme = 'http' | 'https'\n\n/**\n * Type representing HTTP Methods\n *\n */\nexport type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\n/**\n * Type alias representing HTTP Headers\n */\nexport type HTTPHeaders = { [key: string]: string }\n\n/**\n * HTTPHeaderBag is a type alias representing HTTP Headers\n */\nexport type HTTPHeaderBag = Record<string, string>\n\nexport function hasHeader(soughtHeader: string, headers: HTTPHeaderBag): boolean {\n    soughtHeader = soughtHeader.toLowerCase()\n\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            return true\n        }\n    }\n\n    return false\n}\n\n/**\n * QueryParameterBag is a type alias representing HTTP Query Parameters\n */\nexport type QueryParameterBag = Record<string, string | Array<string>>\n\n/**\n * HTTPRequest represents an HTTP request\n */\nexport interface HTTPRequest {\n    /**\n     * The HTTP method to use\n     */\n    method: HTTPMethod\n\n    /**\n     * The protocol to use (http or https)\n     */\n    protocol: HTTPScheme\n\n    /**\n     * The hostname (domain name or IP address) the request targets\n     */\n    hostname: string\n\n    /**\n     * The port to the request targets\n     */\n    port?: number\n\n    /**\n     * The path to the resource\n     */\n    path: string\n\n    /**\n     * The query parameters to include in the request\n     */\n    query?: QueryParameterBag\n\n    /**\n     * The headers to include in the request\n     */\n    headers: HTTPHeaderBag\n\n    /**\n     * The body of the request\n     */\n    body?: string | ArrayBuffer | null\n}\n\n/**\n * SignedHTTPRequest represents an HTTP request that has been signed\n * with an AWS signature. It is a superset of HTTPRequest adding\n * the following fields:\n * - url: the fully qualified URL of the request that can be used in a k6 http.request.\n */\nexport interface SignedHTTPRequest extends HTTPRequest {\n    url: string\n}\n","import crypto from 'k6/crypto'\n\nimport * as constants from './constants'\nimport { AWSError } from './error'\nimport { hasHeader, HTTPHeaderBag, HTTPRequest, QueryParameterBag, SignedHTTPRequest } from './http'\nimport { isArrayBuffer } from './utils'\n\n/**\n * SignatureV4 can be used to sign HTTP requests and presign URLs using the AWS Signature\n * Version 4 signing process.\n *\n * It offers two signing methods:\n * - sign: signs the request headers and payload\n * - presign: returns a presigned (authorization information contained in the query string) URL\n *\n * @see https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nexport class SignatureV4 {\n    /**\n     * The name of the service to sign for.\n     */\n    private readonly service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    private readonly region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    private readonly credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly uriEscapePath: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly applyChecksum: boolean\n\n    // TODO: uriEscapePath and applyChecksum should not be present in the constructor\n    constructor({\n        service,\n        region,\n        credentials,\n        uriEscapePath,\n        applyChecksum,\n    }: SignatureV4Options) {\n        this.service = service\n        this.region = region\n        this.credentials = credentials\n        this.uriEscapePath = typeof uriEscapePath === 'boolean' ? uriEscapePath : true\n        this.applyChecksum = typeof applyChecksum === 'boolean' ? applyChecksum : true\n    }\n\n    /**\n     * Includes AWS v4 signing information to the provided HTTP request.\n     *\n     * This method adds an Authorization header to the request, containing\n     * the signature and other signing information. It also returns a preformatted\n     * URL that can be used to make the k6 http request.\n     *\n     * This method mutates the request object.\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param param1 {SignOptions} Options for signing the request.\n     * @returns {SignedHTTPRequest} The signed request.\n     */\n    sign(\n        request: HTTPRequest,\n        {\n            signingDate = new Date(),\n            signingService,\n            signingRegion,\n            unsignableHeaders = new Set<string>(),\n            signableHeaders = new Set<string>(),\n        }: RequestSigningOptions\n    ): SignedHTTPRequest {\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const service = signingService || this.service\n        const region = signingRegion || this.region\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = request.hostname\n\n        // Filter out headers that will be generated and managed by the signing process.\n        // If the user provide any of those as part of the HTTPRequest's headers, they\n        // will be ignored.\n        for (const headerName of Object.keys(request.headers)) {\n            if (constants.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n                delete request.headers[headerName]\n            }\n        }\n\n        request.headers[constants.AMZ_DATE_HEADER] = longDate\n        if (this.credentials.sessionToken) {\n            request.headers[constants.AMZ_TOKEN_HEADER] = this.credentials.sessionToken\n        }\n\n        // If the request body is a typed array, we need to convert it to a buffer\n        // so that we can calculate the checksum.\n        if (ArrayBuffer.isView(request.body)) {\n            request.body = request.body.buffer\n        }\n\n        // Ensure we avoid passing undefined to the crypto hash function.\n        if (!request.body) {\n            request.body = ''\n        }\n\n        let payloadHash = constants.EMPTY_SHA256\n        if (this.applyChecksum) {\n            if (!hasHeader(constants.AMZ_CONTENT_SHA256_HEADER, request.headers)) {\n                payloadHash = crypto.sha256(request.body, 'hex').toLowerCase()\n                request.headers[constants.AMZ_CONTENT_SHA256_HEADER] = payloadHash\n            } else if (\n                request.headers[constants.AMZ_CONTENT_SHA256_HEADER] === constants.UNSIGNED_PAYLOAD\n            ) {\n                payloadHash = constants.UNSIGNED_PAYLOAD\n            }\n        }\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            unsignableHeaders,\n            signableHeaders\n        )\n        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n        const signingKey = this.deriveSigningKey(this.credentials, service, region, shortDate)\n        const signature = this.calculateSignature(longDate, scope, signingKey, canonicalRequest)\n\n        /**\n         * Step 4 of the signing process: add the signature to the HTTP request's headers.\n         *\n         * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n         */\n        request.headers[constants.AUTHORIZATION_HEADER] =\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER} ` +\n            `Credential=${this.credentials.accessKeyId}/${scope}, ` +\n            `SignedHeaders=${Object.keys(canonicalHeaders).sort().join(';')}, ` +\n            `Signature=${signature}`\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            // We exclude the signature from the query string\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return {\n            url: url,\n            ...request,\n        }\n    }\n\n    /**\n     * Produces a presigned URL with AWS v4 signature information for the provided HTTP request.\n     *\n     * A presigned URL is a URL that contains the authorization information\n     * (signature and other signing information) in the query string. This method\n     * returns a preformatted URL that can be used to make the k6 http request.\n     *\n     * @param originalRequest - The original request to presign.\n     * @param options - Options controlling the signing of the request.\n     * @returns A signed request, including the presigned URL.\n     */\n    presign(originalRequest: HTTPRequest, options: PresignOptions = {}): SignedHTTPRequest {\n        const {\n            signingDate = new Date(),\n            expiresIn = 3600,\n            unsignableHeaders,\n            unhoistableHeaders,\n            signableHeaders,\n            signingRegion,\n            signingService,\n        } = options\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const region = signingRegion || this.region\n        const service = signingService || this.service\n\n        if (expiresIn > constants.MAX_PRESIGNED_TTL) {\n            throw new InvalidSignatureError(\n                \"Signature version 4 presigned URLs can't be valid for more than 7 days\"\n            )\n        }\n\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n        const request = this.moveHeadersToQuery(originalRequest, { unhoistableHeaders })\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = originalRequest.hostname\n\n        // If the user provided a session token, include it in the signed url query string.\n        if (this.credentials.sessionToken) {\n            request.query[constants.AMZ_TOKEN_QUERY_PARAM] = this.credentials.sessionToken\n        }\n\n        // Add base signing query parameters to the request, as described in the documentation\n        // @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n        request.query[constants.AMZ_ALGORITHM_QUERY_PARAM] = constants.SIGNING_ALGORITHM_IDENTIFIER\n        request.query[\n            constants.AMZ_CREDENTIAL_QUERY_PARAM\n        ] = `${this.credentials.accessKeyId}/${scope}`\n        request.query[constants.AMZ_DATE_QUERY_PARAM] = longDate\n        request.query[constants.AMZ_EXPIRES_QUERY_PARAM] = expiresIn.toString(10)\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            unsignableHeaders,\n            signableHeaders\n        )\n        request.query[constants.AMZ_SIGNED_HEADERS_QUERY_PARAM] = Object.keys(canonicalHeaders)\n            .sort()\n            .join(';')\n\n        const signingKey = this.deriveSigningKey(this.credentials, service, region, shortDate)\n\n        // Computing the payload from the original request. This is required\n        // in the event the user attempts to produce a presigned URL for s3,\n        // which requires the payload hash to be 'UNSIGNED-PAYLOAD'.\n        //\n        // To that effect, users need to set the 'x-amz-content-sha256' header,\n        // and mark it as unhoistable and unsignable. When setup this way,\n        // the computePayloadHash method will then return the string 'UNSIGNED-PAYLOAD'.\n        const payloadHash = this.computePayloadHash(originalRequest)\n        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n\n        request.query[constants.AMZ_SIGNATURE_QUERY_PARAM] = this.calculateSignature(\n            longDate,\n            scope,\n            signingKey,\n            canonicalRequest\n        )\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return { url: url, ...request }\n    }\n\n    /**\n     * Create a string including information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * Step 1 of the signing process: create the canonical request string.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param canonicalHeaders {HTTPHeaderBag} The request's canonical headers.\n     * @param payloadHash {string} The hexadecimally encoded request's payload hash .\n     * @returns {string} The canonical request string.\n     */\n    private createCanonicalRequest(\n        request: HTTPRequest,\n        canonicalHeaders: HTTPHeaderBag,\n        payloadHash: string\n    ): string {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort()\n        const sortedCanonicalHeaders = sortedHeaders\n            .map((name) => `${name}:${canonicalHeaders[name]}`)\n            .join('\\n')\n        const signedHeaders = sortedHeaders.join(';')\n\n        return (\n            `${request.method}\\n` +\n            `${this.computeCanonicalURI(request)}\\n` +\n            `${this.computeCanonicalQuerystring(request)}\\n` +\n            `${sortedCanonicalHeaders}\\n\\n` +\n            `${signedHeaders}\\n` +\n            `${payloadHash}`\n        )\n    }\n\n    /**\n     * Create the \"string to sign\" part of the signature Version 4 protocol.\n     *\n     * The \"string to sign\" includes meta information about your request and\n     * about the canonical request that you created with `createCanonicalRequest`.\n     * It is used hand in hand with the signing key to create the request signature.\n     * Step 2 of the signing process: create the string to sign.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The \"string to sign\".\n     */\n    private createStringToSign(\n        longDate: string,\n        credentialScope: string,\n        canonicalRequest: string\n    ): string {\n        const hashedCanonicalRequest = crypto.sha256(canonicalRequest, 'hex')\n\n        return (\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER}\\n` +\n            `${longDate}\\n` +\n            `${credentialScope}\\n` +\n            `${hashedCanonicalRequest}`\n        )\n    }\n\n    /**\n     * Calculte the signature for AWS signature version 4.\n     *\n     * Step 3 of the signing process: create the signature.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param signingKey {string} the signing key as computed by the deriveSigningKey method.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The signature.\n     */\n    private calculateSignature(\n        longDate: string,\n        credentialScope: string,\n        signingKey: Uint8Array,\n        canonicalRequest: string\n    ): string {\n        const stringToSign = this.createStringToSign(longDate, credentialScope, canonicalRequest)\n        return crypto.hmac('sha256', signingKey, stringToSign, 'hex')\n    }\n\n    /**\n     * Derives the signing key for authenticating requests signed with\n     * the Signature version 4 authentication protocol.\n     *\n     * deriveSigningKey produces a signing key by creating a series of\n     * hash-based message authentication codes (HMACs) represented in\n     * a binary format.\n     *\n     * The derived signing key is specific to the date it's made at, as well as\n     * the service and region it targets.\n     *\n     * @param credentials {AWSCredentials} The credentials to use for signing.\n     * @param service {string} The service the request is targeted at.\n     * @param region {string} The region the request is targeted at.\n     * @param shortDate {string} The request's date in YYYYMMDD format.\n     * @returns {Uint8Array} The derived signing key.\n     */\n    private deriveSigningKey(\n        credentials: Credentials,\n        service: string,\n        region: string,\n        shortDate: string\n    ): Uint8Array {\n        const kSecret = credentials.secretAccessKey\n        const kDate: any = crypto.hmac('sha256', 'AWS4' + kSecret, shortDate, 'binary')\n        const kRegion: any = crypto.hmac('sha256', kDate, region, 'binary')\n        const kService: any = crypto.hmac('sha256', kRegion, service, 'binary')\n        const kSigning: any = crypto.hmac('sha256', kService, 'aws4_request', 'binary')\n\n        return kSigning\n    }\n\n    /**\n     * Create a string that includes information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * @param param0 {HTTPRequest} The request to sign.\n     * @returns {string} The canonical URI.\n     */\n    private computeCanonicalURI({ path }: HTTPRequest): string {\n        if (!this.uriEscapePath) {\n            // If the path is not uri-escaped, as in S3, then there's no need to\n            // double encode it nor normalize it.\n            return path\n        }\n\n        const normalizedURISegments = []\n\n        for (const URISegment of path.split('/')) {\n            if (URISegment?.length == 0) {\n                continue\n            }\n\n            if (URISegment === '.') {\n                continue\n            }\n\n            if (URISegment === '..') {\n                normalizedURISegments.pop()\n            } else {\n                normalizedURISegments.push(URISegment)\n            }\n        }\n\n        // Normalize and double encode the URI\n        const leading = path?.startsWith('/') ? '/' : ''\n        const URI = normalizedURISegments.join('/')\n        const trailing = normalizedURISegments.length > 0 && path?.endsWith('/') ? '/' : ''\n        const normalizedURI = `${leading}${URI}${trailing}`\n\n        const doubleEncoded = encodeURIComponent(normalizedURI)\n\n        return doubleEncoded.replace(/%2F/g, '/')\n    }\n\n    /**\n     * Serializes the request's query parameters into their canonical\n     * string version. If the request does not include a query parameters,\n     * returns an empty string.\n     *\n     * @param param0 {HTTPRequest} The request containing the query parameters.\n     * @returns {string} The canonical query string.\n     */\n    private computeCanonicalQuerystring({ query = {} }: HTTPRequest): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (key.toLowerCase() === constants.AMZ_SIGNATURE_HEADER) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n\n    /**\n     * Create the canonical form of the request's headers.\n     * Canonical headers consist of all the HTTP headers you\n     * are including with the signed request.\n     *\n     * @param param0 {HTTPRequest} The request to compute the canonical headers of.\n     * @param unsignableHeaders {Set<string>} The headers that should not be signed.\n     * @param signableHeaders {Set<string>} The headers that should be signed.\n     * @returns {string} The canonical headers.\n     */\n    private computeCanonicalHeaders(\n        { headers }: HTTPRequest,\n        unsignableHeaders?: Set<string>,\n        signableHeaders?: Set<string>\n    ): HTTPHeaderBag {\n        const canonicalHeaders: HTTPHeaderBag = {}\n\n        for (const headerName of Object.keys(headers).sort()) {\n            if (headers[headerName] == undefined) {\n                continue\n            }\n\n            const canonicalHeaderName = headerName.toLowerCase()\n            if (\n                canonicalHeaderName in constants.ALWAYS_UNSIGNABLE_HEADERS ||\n                unsignableHeaders?.has(canonicalHeaderName)\n            ) {\n                if (\n                    !signableHeaders ||\n                    (signableHeaders && !signableHeaders.has(canonicalHeaderName))\n                ) {\n                    continue\n                }\n            }\n\n            canonicalHeaders[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, ' ')\n        }\n\n        return canonicalHeaders\n    }\n\n    /**\n     * Computes the SHA256 cryptographic hash of the request's body.\n     *\n     * If the headers contain the 'X-Amz-Content-Sha256' header, then\n     * the value of that header is returned instead. This proves useful\n     * when, for example, presiging a URL for S3, as the payload hash\n     * must always be equal to 'UNSIGNED-PAYLOAD'.\n     *\n     * @param param0 {HTTPRequest} The request to compute the payload hash of.\n     * @returns {string} The hex encoded SHA256 payload hash, or the value of the 'X-Amz-Content-Sha256' header.\n     */\n    private computePayloadHash({ headers, body }: HTTPRequest): string {\n        for (const headerName of Object.keys(headers)) {\n            // If the header is present, return its value.\n            // So that we let the 'UNSIGNED-PAYLOAD' value pass through.\n            if (headerName.toLowerCase() === constants.AMZ_CONTENT_SHA256_HEADER) {\n                return headers[headerName]\n            }\n        }\n\n        if (body == undefined) {\n            return constants.EMPTY_SHA256\n        }\n\n        if (typeof body === 'string' || isArrayBuffer(body)) {\n            return crypto.sha256(body, 'hex').toLowerCase()\n        }\n\n        if (ArrayBuffer.isView(body)) {\n            // If the request body is a typed array, we need to convert it to a buffer\n            // so that we can calculate the checksum.\n            return crypto.sha256((body as DataView).buffer, 'hex').toLowerCase()\n        }\n\n        return constants.UNSIGNED_PAYLOAD\n    }\n\n    /**\n     * Moves a request's headers to its query parameters.\n     *\n     * The operation will ignore any amazon standard headers, prefixed\n     * with 'X-Amz-'. It will also ignore any headers specified as unhoistable\n     * by the options.\n     *\n     * The operation will delete the headers from the request.\n     *\n     * @param request {HTTPRequest} The request to move the headers from.\n     * @param options\n     * @returns {HTTPRequest} The request with the headers moved to the query parameters.\n     */\n    private moveHeadersToQuery(\n        request: HTTPRequest,\n        options: { unhoistableHeaders?: Set<string> } = {}\n    ): HTTPRequest & { query: QueryParameterBag } {\n        const requestCopy = JSON.parse(JSON.stringify(request))\n        const { headers, query = {} as QueryParameterBag } = requestCopy\n\n        for (const name of Object.keys(headers)) {\n            const lowerCaseName = name.toLowerCase()\n            if (\n                lowerCaseName.slice(0, 6) === 'x-amz-' &&\n                !options.unhoistableHeaders?.has(lowerCaseName)\n            ) {\n                query[name] = headers[name]\n                delete headers[name]\n            }\n        }\n\n        return {\n            ...requestCopy,\n            headers,\n            query,\n        }\n    }\n\n    /**\n     * Serializes a HTTPRequest's query parameter bag into a string.\n     *\n     * @param query {QueryParameterBag} The query parameters to serialize.\n     * @param ignoreKeys {Set<string>} The keys to ignore.\n     * @returns {string} The serialized, and ready to use in a URL, query parameters.\n     */\n    private serializeQueryParameters(query: QueryParameterBag, ignoreKeys?: string[]): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (ignoreKeys?.includes(key.toLowerCase())) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code?: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\nexport interface SignatureV4Options {\n    /**\n     * The name of the service to sign for.\n     */\n    service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    uriEscapePath?: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    applyChecksum?: boolean\n}\n\nexport interface SignOptions {\n    /**\n     * The date and time to be used as signature metadata. This value should be\n     * a Date object, a unix (epoch) timestamp, or a string that can be\n     * understood by the JavaScript `Date` constructor.If not supplied, the\n     * value returned by `new Date()` will be used.\n     */\n    signingDate?: Date\n\n    /**\n     * The service signing name. It will override the service name of the signer\n     * in current invocation\n     */\n    signingService?: string\n\n    /**\n     * The region name to sign the request. It will override the signing region of the\n     * signer in current invocation\n     */\n    signingRegion?: string\n}\n\nexport interface RequestSigningOptions extends SignOptions {\n    /**\n     * A set of strings whose members represents headers that cannot be signed.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unsignableHeaders set.\n     */\n    unsignableHeaders?: Set<string>\n\n    /**\n     * A set of strings whose members represents headers that should be signed.\n     * Any values passed here will override those provided via unsignableHeaders,\n     * allowing them to be signed.\n     *\n     * All headers in the provided request will have their names converted to\n     * lower case before signing.\n     */\n    signableHeaders?: Set<string>\n}\n\nexport interface PresignOptions extends RequestSigningOptions {\n    /**\n     * The number of seconds before the presigned URL expires\n     */\n    expiresIn?: number\n\n    /**\n     * A set of strings whose representing headers that should not be hoisted\n     * to presigned request's query string. If not supplied, the presigner\n     * moves all the AWS-specific headers (starting with `x-amz-`) to the request\n     * query string. If supplied, these headers remain in the presigned request's\n     * header.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unhoistableHeaders set.\n     */\n    unhoistableHeaders?: Set<string>\n}\n\nexport interface Credentials {\n    /**\n     * AWS access key ID\n     */\n    readonly accessKeyId: string\n\n    /**\n     * AWS secret access key\n     */\n    readonly secretAccessKey: string\n\n    /**\n     * A security or session token to use with these credentials. Usually\n     * present for temporary credentials.\n     */\n    readonly sessionToken?: string\n}\n\nexport interface DateInfo {\n    /**\n     * ISO8601 formatted date string\n     */\n    longDate: string\n\n    /**\n     * String in the format YYYYMMDD\n     */\n    shortDate: string\n}\n\n/**\n * Escapes a URI following the AWS signature v4 escaping rules.\n *\n * @param URI {string} The URI to escape.\n * @returns {string} The escaped URI.\n */\nfunction escapeURI(URI: string): string {\n    const hexEncode = (c: string): string => {\n        return `%${c.charCodeAt(0).toString(16).toUpperCase()}`\n    }\n\n    return encodeURIComponent(URI).replace(/[!'()*]/g, hexEncode)\n}\n\n/**\n * formatDate formats a Date object into a ISO8601 formatted date string\n * and a string in the format YYYYMMDD.\n *\n * @param date {Date} The date to format.\n * @returns {DateInfo} The formatted date.\n */\nfunction formatDate(date: Date): DateInfo {\n    const longDate = iso8601(date).replace(/[\\-:]/g, '')\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    }\n}\n\n/**\n * Formats a time into an ISO 8601 string.\n *\n * @see https://en.wikipedia.org/wiki/ISO_8601\n *\n * @param time {number | string | Date} The time to format.\n * @returns {string} The ISO 8601 formatted time.\n */\nfunction iso8601(time: number | string | Date): string {\n    return toDate(time)\n        .toISOString()\n        .replace(/\\.\\d{3}Z$/, 'Z')\n}\n\n/**\n * Converts a time value into a Date object.\n *\n * @param time {number | string | Date} The time to convert.\n * @returns {Date} The resulting Date object.\n */\nfunction toDate(time: number | string | Date): Date {\n    if (typeof time === 'number') {\n        return new Date(time * 1000)\n    }\n\n    if (typeof time === 'string') {\n        if (Number(time)) {\n            return new Date(Number(time) * 1000)\n        }\n\n        return new Date(time)\n    }\n\n    return time\n}\n","/**\n *\n * @param value\n * @returns\n */\nexport function isArrayBuffer(value: any): value is ArrayBuffer {\n    return (\n        typeof ArrayBuffer === 'function' &&\n        (value instanceof ArrayBuffer ||\n            Object.prototype.toString.call(value) === '[object ArrayBuffer]')\n    )\n}\n\nexport function toFormUrlEncoded(form: any): string {\n    return Object.keys(form).reduce((params, key) => {\n        let value = form[key]\n        if (value !== undefined && value !== null) {\n            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\n        }\n        return params;\n    }, [] as string[]).join('&')\n}","import { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { SignatureV4 } from './signature'\nimport { HTTPHeaders, SignedHTTPRequest } from './http'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\nimport { toFormUrlEncoded } from './utils'\nimport { AWSError } from './error'\n\nconst API_VERSION = '2012-11-05'\n\nexport class SQSClient extends AWSClient {\n    private readonly signature: SignatureV4\n    private readonly commonHeaders: HTTPHeaders\n\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'sqs')\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: this.awsConfig.region,\n            credentials: {\n                accessKeyId: this.awsConfig.accessKeyId,\n                secretAccessKey: this.awsConfig.secretAccessKey,\n                sessionToken: this.awsConfig.sessionToken\n            },\n            uriEscapePath: false,\n            applyChecksum: true\n        })\n\n        this.commonHeaders = {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n    }\n\n    /**\n     * Delivers a message to the specified queue.\n     * \n     * @param {string} queueUrl - The URL of the Amazon SQS queue to which a message is sent. Queue URLs and names are case-sensitive.\n     * @param {string} messageBody - The message to send. The minimum size is one character. The maximum size is 256 KB.\n     * @param {Object} options - Options for the request\n     * @param {string} [options.messageDeduplicationId] - The message deduplication id.\n     * @param {string} [options.messageGroupId] - The message group ID for FIFO queues\n     * @returns {Message} - The message that was sent.\n     */\n    sendMessage(queueUrl: string, messageBody: string, options: { messageDeduplicationId?: string; messageGroupId?: string} = {}): Message {\n        const method = 'POST'\n\n        let body: any = {\n            Action: 'SendMessage',\n            Version: API_VERSION,\n            QueueUrl: queueUrl,\n            MessageBody: messageBody,\n        }\n\n        if (typeof(options.messageDeduplicationId) !== 'undefined') {\n            body = { ...body,\n                MessageDeduplicationId: options.messageDeduplicationId\n            }\n        }\n\n        if (typeof(options.messageGroupId) !== 'undefined') {\n            body = { ...body,\n                MessageGroupId: options.messageGroupId\n            }\n        }\n\n        const signedRequest: SignedHTTPRequest = this.signature.sign(\n            {\n                method: 'POST',\n                protocol: 'https',\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders\n                },\n                body: toFormUrlEncoded(body)\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers\n        })\n        this._handleError(res)\n\n        const parsed = res.html('SendMessageResponse > SendMessageResult')\n        return new Message(   \n            parsed.find('MessageId').text(),\n            parsed.find('MD5OfMessageBody').text()\n        )\n    }\n\n    /**\n     * Returns a list of your queues in the current region.\n     * \n     * @param {ListQueuesRequestParameters} [parameters={}] request parameters\n     * @param {number} [ListQueuesRequestParameters.maxResults] Maximum number of results to include in the response. Value range is 1 to 1000. You must set maxResults to receive a value for nextToken in the response.\n     * @param {string} [ListQueuesRequestParameters.nextToken] Pagination token to request the next set of results.\n     * @param {string} [ListQueuesRequestParameters.queueNamePrefix] A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned.\n     * @returns {Object}\n     * @returns {string[]} Object.queueUrls - A list of queue URLs, up to 1000 entries.\n     * @returns {string} [Object.nextToken] - In the future, you can use NextToken to request the next set of results.\n     */\n    listQueues(parameters: ListQueuesRequestParameters = {}): ListQueuesResponse {\n        const method = 'POST'\n        \n        let body: any = {\n            Action: 'ListQueues',\n            Version: API_VERSION,\n        }\n\n        if (typeof(parameters?.maxResults) !== 'undefined') {\n            body = { ...body,\n                MaxResults: parameters.maxResults\n            }\n        }\n\n        if (typeof(parameters?.nextToken) !== 'undefined') {\n            body = { ...body,\n                NextToken: parameters.nextToken\n            }\n        }\n\n        if (typeof(parameters?.queueNamePrefix) !== 'undefined') {\n            body = { ...body,\n                QueueNamePrefix: parameters.queueNamePrefix\n            }\n        }\n\n        const signedRequest: SignedHTTPRequest = this.signature.sign(\n            {\n                method: 'POST',\n                protocol: 'https',\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    'Host': this.host\n                },\n                body: toFormUrlEncoded(body)\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers\n        })\n        this._handleError(res)\n\n        let parsed = res.html()\n        return {\n            urls: parsed.find('QueueUrl').toArray().map(e => e.text()),\n            nextToken: parsed.find('NextToken').text() || undefined\n        }\n    }\n\n    private _handleError(response: RefinedResponse<ResponseType | undefined>) {\n        const errorCode: number = response.error_code\n        const errorMessage: string = response.error\n\n        if (errorMessage == '' && errorCode === 0) {\n            return\n        }\n\n        throw AWSError.parseXML(response.body as string)\n    }\n}\n\n/**\n * An Amazon SQS message.\n */\nexport class Message {\n    /**\n     * A unique identifier for the message.\n     * A MessageIdis considered unique across all AWS accounts for an extended period of time.\n     */\n    id: string\n    \n    /**\n     * An MD5 digest of the non-URL-encoded message body string.\n     */\n    bodyMD5: string\n\n    /**\n     * Instantiates a new Message object.\n     * \n     * @param id\n     * @param md5Ofbody \n     */\n    constructor(id: string, bodyMD5: string) {\n        this.id = id\n        this.bodyMD5 = bodyMD5\n    }\n}\n\nexport interface SendMessageOptions {\n    /*\n     * The message deduplication ID for FIFO queues\n    */\n    messageDeduplicationId?: string\n    \n    /*\n     * The message group ID for FIFO queues\n     */\n    messageGroupId?: string\n}\n\nexport interface ListQueuesRequestParameters {\n    /**\n     * Maximum number of results to include in the response. Value range is 1 to 1000.\n     */\n    maxResults?: number\n    /**\n     * Pagination token to request the next set of results.\n     */\n    nextToken?: string\n    /**\n     * A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned.\n     * Queue URLs and names are case-sensitive.\n     */\n    queueNamePrefix?: string\n}\n\nexport interface ListQueuesResponse {\n    /**\n     * A list of queue URLs, up to 1,000 entries, or the value of MaxResults you sent in the request.\n     */\n    urls: string[]\n    /**\n     * Pagination token to include in the next request.\n     */\n    nextToken?: string\n}","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","module.exports = require(\"k6/crypto\");","module.exports = require(\"k6/html\");","module.exports = require(\"k6/http\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { JSONArray, JSONObject } from 'k6'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { AMZ_TARGET_HEADER } from './constants'\nimport { AWSError } from './error'\nimport { HTTPHeaders, HTTPMethod } from './http'\nimport { InvalidSignatureError, SignatureV4 } from './signature'\n\n/**\n * Class allowing to interact with Amazon AWS's KMS service\n */\nexport class KMSClient extends AWSClient {\n    method: HTTPMethod\n    commonHeaders: HTTPHeaders\n\n    signature: SignatureV4\n\n    /**\n     * Create a KMSClient\n     * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'kms')\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: awsConfig.region,\n            credentials: {\n                accessKeyId: awsConfig.accessKeyID,\n                secretAccessKey: awsConfig.secretAccessKey,\n            },\n            uriEscapePath: false,\n            applyChecksum: false,\n        })\n\n        // All interactions with the KMS service\n        // are made via the GET or POST method.\n        this.method = 'POST'\n\n        this.commonHeaders = {\n            'Content-Type': 'application/x-amz-json-1.1',\n        }\n    }\n\n    /**\n     * Gets a list of all the KMS keys in the caller's AWS\n     * account and region.\n     *\n     * @returns an array of all the available keys\n     */\n    listKeys(): Array<KMSKey> {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    // For some reason, the base target is not kms...\n                    [AMZ_TARGET_HEADER]: `TrentService.ListKeys`,\n                },\n                body: JSON.stringify({}),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(KMSOperation.ListKeys, res)\n\n        const json: JSONArray = res.json('Keys') as JSONArray\n        return json.map((k) => KMSKey.fromJSON(k as JSONObject))\n    }\n\n    /**\n     * GenerateDataKey returns a unique symmetric data key for use outside of AWS KMS.\n     *\n     * This operation returns a plaintext copy of the data key and a copy that is encrypted under a symmetric encryption KMS key that you specify.\n     * The bytes in the plaintext key are random; they are not related to the caller or the KMS key.\n     * You can use the plaintext key to encrypt your data outside of AWS KMS and store the encrypted data key with the encrypted data.\n     *\n     * To generate a data key, specify the symmetric encryption KMS key that will be used to encrypt the data key.\n     * You cannot use an asymmetric KMS key to encrypt data keys.\n     *\n     * Used to generate data key with the KMS key defined\n     * @param {string} id - Specifies the symmetric encryption KMS key that encrypts the data key. Use its key ID, key ARN, alias name, or alias ARN.\n     * @param {KMKeySize} size - Specifies the length of the data key in bytes. For example, use the value 64 to generate a 512-bit data key (64 bytes is 512 bits). Default is 32, and generates a 256-bit data key.\n     * @throws {KMSServiceError}\n     * @throws {InvalidSignatureError}\n     * @returns {KMSDataKey} - The generated data key.\n     */\n    generateDataKey(id: string, size: KMSKeySize = KMSKeySize.Size256): KMSDataKey | undefined {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    // For some reason, the base target is not kms...\n                    [AMZ_TARGET_HEADER]: `TrentService.GenerateDataKey`,\n                },\n                body: JSON.stringify({ KeyId: id, NumberOfBytes: size }),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(KMSOperation.GenerateDataKey, res)\n\n        return KMSDataKey.fromJSON(res.json() as JSONObject)\n    }\n\n    _handle_error(operation: KMSOperation, response: RefinedResponse<ResponseType | undefined>) {\n        const errorCode = response.error_code\n        if (errorCode === 0) {\n            return\n        }\n\n        const error = response.json() as JSONObject\n        if (errorCode >= 1400 && errorCode <= 1499) {\n            // In the event of certain errors, the message is not set.\n            // Also, note the inconsistency in casing...\n            const errorMessage: string =\n                (error.Message as string) || (error.message as string) || (error.__type as string)\n\n            // Handle specifically the case of an invalid signature\n            if (error.__type === 'InvalidSignatureException') {\n                throw new InvalidSignatureError(errorMessage, error.__type)\n            }\n\n            // Otherwise throw a standard service error\n            throw new KMSServiceError(errorMessage, error.__type as string, operation)\n        }\n\n        if (errorCode === 1500) {\n            throw new KMSServiceError(\n                'An error occured on the server side',\n                'InternalServiceError',\n                operation\n            )\n        }\n    }\n}\n\n/**\n * Class representing a KMS key\n */\nexport class KMSKey {\n    /**\n     * ARN of the key\n     */\n    keyArn: string\n\n    /**\n     * Unique identifier of the key\n     */\n    keyId: string\n\n    constructor(keyArn: string, KeyId: string) {\n        this.keyArn = keyArn\n        this.keyId = KeyId\n    }\n\n    static fromJSON(json: JSONObject) {\n        return new KMSKey(json.KeyArn as string, json.KeyId as string)\n    }\n}\n\n/**\n * Class representing a data key\n */\nexport class KMSDataKey {\n    /**\n     * The Amazon Resource Name (key ARN) of the KMS key that encrypted the data key.\n     */\n    id: string\n\n    /**\n     * The (base64-encoded) encrypted copy of the data key.\n     */\n    ciphertextBlob: string\n\n    /**\n     * The plaintext data key.\n     * Use this data key to encrypt your data outside of KMS. Then, remove it from memory as soon as possible.\n     */\n    plaintext: string\n\n    constructor(CiphertextBlob: string, KeyId: string, Plaintext: string) {\n        this.ciphertextBlob = CiphertextBlob\n        this.id = KeyId\n        this.plaintext = Plaintext\n    }\n\n    static fromJSON(json: JSONObject) {\n        return new KMSDataKey(\n            json.CiphertextBlob as string,\n            json.KeyId as string,\n            json.Plaintext as string\n        )\n    }\n}\n\nexport class KMSServiceError extends AWSError {\n    operation: KMSOperation\n\n    /**\n     * Constructs a KMSServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: KMSOperation) {\n        super(message, code)\n        this.name = 'KMSServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n *  KMSOperation defines all currently implemented KMS Service operations.\n */\nenum KMSOperation {\n    GenerateDataKey = 'GenerateDataKey',\n    ListKeys = 'ListKeys',\n}\n\n/**\n *  KMSKeyLength describes possible key lenght values for KMS API data key operations.\n */\nenum KMSKeySize {\n    Size256 = 32,\n    Size512 = 64,\n}\n","import { bytes } from 'k6'\nimport { parseHTML } from 'k6/html'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { AWSError } from './error'\nimport { SignedHTTPRequest } from './http'\nimport { InvalidSignatureError, SignatureV4 } from './signature'\n\n/** Class allowing to interact with Amazon AWS's S3 service */\nexport class S3Client extends AWSClient {\n    signature: SignatureV4\n\n    /**\n     * Create a S3Client\n     *\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 's3')\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: this.awsConfig.region,\n            credentials: {\n                accessKeyId: this.awsConfig.accessKeyId,\n                secretAccessKey: this.awsConfig.secretAccessKey,\n                sessionToken: this.awsConfig.sessionToken,\n            },\n            uriEscapePath: false,\n            applyChecksum: true,\n        })\n    }\n\n    /**\n     * Returns a list of all buckets owned by the authenticated sender of the request.\n     * To use this operation, you must have the s3:ListAllMyBuckets permission.\n     *\n     * @return  {Array.<S3Bucket>} buckets - An array of objects describing S3 buckets\n     *     with the following fields: name, and creationDate.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    listBuckets(): Array<S3Bucket> {\n        const method = 'GET'\n\n        const signedRequest: SignedHTTPRequest = this.signature.sign(\n            {\n                method: 'GET',\n                protocol: 'https',\n                hostname: this.host,\n                path: '/',\n                headers: {},\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers,\n        })\n        this._handle_error('ListBuckets', res)\n\n        let buckets: Array<S3Bucket> = []\n\n        const doc = parseHTML(res.body as string)\n\n        doc.find('Buckets')\n            .children()\n            .each((_, bucketDefinition) => {\n                let bucket = {}\n\n                bucketDefinition.children().forEach((child) => {\n                    switch (child.nodeName()) {\n                        case 'name':\n                            Object.assign(bucket, { name: child.textContent() })\n                            break\n                        case 'creationdate':\n                            Object.assign(bucket, {\n                                creationDate: Date.parse(child.textContent()),\n                            })\n                    }\n                })\n\n                buckets.push(bucket as S3Bucket)\n            })\n\n        return buckets\n    }\n\n    /**\n     * Returns some or all (up to 1,000) of the objects in a bucket.\n     *\n     * @param  {string} bucketName - Bucket name to list.\n     * @param  {string?} prefix='' - Limits the response to keys that begin with the specified prefix.\n     * @return {Array.<S3Object>} - returns an array of objects describing S3 objects\n     *     with the following fields: key, lastModified, etag, size and storageClass.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    listObjects(bucketName: string, prefix?: string): Array<S3Object> {\n        // Prepare request\n        const method = 'GET'\n        const host = `${bucketName}.${this.host}`\n\n        const signedRequest: SignedHTTPRequest = this.signature.sign(\n            {\n                method: 'GET',\n                protocol: 'https',\n                hostname: host,\n                path: '/',\n                query: {\n                    'list-type': '2',\n                    prefix: prefix || '',\n                },\n                headers: {},\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers,\n        })\n        this._handle_error('ListObjectsV2', res)\n\n        let objects: Array<S3Object> = []\n\n        // Extract the objects definition from\n        // the XML response\n        parseHTML(res.body as string)\n            .find('Contents')\n            .each((_, objectDefinition) => {\n                let obj = {}\n\n                objectDefinition.children().forEach((child) => {\n                    switch (child.nodeName()) {\n                        case 'key':\n                            Object.assign(obj, { key: child.textContent() })\n                            break\n                        case 'lastmodified':\n                            Object.assign(obj, { lastModified: Date.parse(child.textContent()) })\n                            break\n                        case 'etag':\n                            Object.assign(obj, { etag: child.textContent() })\n                            break\n                        case 'size':\n                            Object.assign(obj, { size: parseInt(child.textContent()) })\n                            break\n                        case 'storageclass':\n                            Object.assign(obj, { storageClass: child.textContent() })\n                    }\n                })\n\n                objects.push(obj as S3Object)\n            })\n\n        return objects\n    }\n    /**\n     * Retrieves an Object from Amazon S3.\n     *\n     * To use getObject, you must have `READ` access to the object.\n     *\n     * @param  {string} bucketName - The bucket name containing the object.\n     * @param  {string} objectKey - Key of the object to get.\n     * @return {S3Object} - returns the content of the fetched S3 Object.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    getObject(bucketName: string, objectKey: string): S3Object {\n        // Prepare request\n        const method = 'GET'\n        const host = `${bucketName}.${this.host}`\n\n        const signedRequest = this.signature.sign(\n            {\n                method: 'GET',\n                protocol: 'https',\n                hostname: host,\n                path: `/${objectKey}`,\n                headers: {},\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers,\n        })\n        this._handle_error('GetObject', res)\n\n        return new S3Object(\n            objectKey,\n            Date.parse(res.headers['Last-Modified']),\n            res.headers['ETag'],\n            parseInt(res.headers['Content-Length']),\n\n            // The X-Amz-Storage-Class header is only set if the storage class is\n            // not the default 'STANDARD' one.\n            (res.headers['X-Amz-Storage-Class'] ?? 'STANDARD') as StorageClass,\n\n            res.body\n        )\n    }\n    /**\n     * Adds an object to a bucket.\n     *\n     * You must have WRITE permissions on a bucket to add an object to it.\n     *\n     * @param  {string} bucketName - The bucket name containing the object.\n     * @param  {string} objectKey - Key of the object to put.\n     * @param  {string | ArrayBuffer} data - the content of the S3 Object to upload.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    putObject(bucketName: string, objectKey: string, data: string | ArrayBuffer) {\n        // Prepare request\n        const method = 'PUT'\n        const host = `${bucketName}.${this.host}`\n\n        const signedRequest = this.signature.sign(\n            {\n                method: method,\n                protocol: 'https',\n                hostname: host,\n                path: `/${objectKey}`,\n                headers: {},\n                body: data,\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error('PutObject', res)\n    }\n\n    /**\n     * Removes the null version (if there is one) of an object and inserts a delete marker,\n     * which becomes the latest version of the object.\n     *\n     * @param  {string} bucketName - The bucket name containing the object.\n     * @param  {string} objectKey - Key of the object to delete.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    deleteObject(bucketName: string, objectKey: string): void {\n        // Prepare request\n        const method = 'DELETE'\n        const host = `${bucketName}.${this.host}`\n\n        const signedRequest = this.signature.sign(\n            {\n                method: method,\n                protocol: 'https',\n                hostname: host,\n                path: `/${objectKey}`,\n                headers: {},\n            },\n            {}\n        )\n\n        const res = http.request(method, signedRequest.url, signedRequest.body || '', {\n            headers: signedRequest.headers,\n        })\n        this._handle_error('DeleteObject', res)\n    }\n\n    _handle_error(operation: S3Operation, response: RefinedResponse<ResponseType | undefined>) {\n        const errorCode: number = response.error_code\n        const errorMessage: string = response.error\n\n        if (errorMessage == '' && errorCode === 0) {\n            return\n        }\n\n        // FIXME: should be errorCode === 1301 instead\n        // See: https://github.com/grafana/k6/issues/2474\n        // See: https://github.com/golang/go/issues/49281\n        if (errorMessage && errorMessage.startsWith('301')) {\n            throw new S3ServiceError('Resource not found', 'ResourceNotFound', operation)\n        }\n\n        const awsError = AWSError.parseXML(response.body as string)\n        switch (awsError.code) {\n            case 'AuthorizationHeaderMalformed':\n                throw new InvalidSignatureError(awsError.message, awsError.code)\n            default:\n                throw new S3ServiceError(awsError.message, awsError.code || 'unknown', operation)\n        }\n    }\n}\n\n/** Class representing a S3 Bucket */\nexport class S3Bucket {\n    name: string\n    creationDate: Date\n\n    /**\n     * Create an S3 Bucket\n     *\n     * @param  {string} name - S3 bucket's name\n     * @param  {Date} creationDate - S3 bucket's creation date\n     */\n    constructor(name: string, creationDate: Date) {\n        this.name = name\n        this.creationDate = creationDate\n    }\n}\n\n/** Class representing an S3 Object */\nexport class S3Object {\n    key: string\n    lastModified: number\n    etag: string\n    size: number\n    storageClass: StorageClass\n    data?: string | bytes | null\n\n    /**\n     * Create an S3 Object\n     *\n     * @param  {string} key - S3 object's key\n     * @param  {Date} lastModified - S3 object last modification date\n     * @param  {string} etag - S3 object's etag\n     * @param  {number} size - S3 object's size\n     * @param  {StorageClass} storageClass - S3 object's storage class\n     * @param  {string | bytes | null} data=null - S3 Object's data\n     */\n    constructor(\n        key: string,\n        lastModified: number,\n        etag: string,\n        size: number,\n        storageClass: StorageClass,\n        data?: string | bytes | null\n    ) {\n        this.key = key\n        this.lastModified = lastModified\n        this.etag = etag\n        this.size = size\n        this.storageClass = storageClass\n        this.data = data\n    }\n}\n\n/**\n * Error indicating a S3 operation failed\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class S3ServiceError extends AWSError {\n    operation: string\n\n    /**\n     * Constructs a S3ServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: string) {\n        super(message, code)\n        this.name = 'S3ServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n * S3Operation describes possible values for S3 API operations,\n * as defined by AWS APIs.\n */\ntype S3Operation = 'ListBuckets' | 'ListObjectsV2' | 'GetObject' | 'PutObject' | 'DeleteObject'\n\n/**\n * Describes the class of storage used to store a S3 object.\n */\ntype StorageClass =\n    | 'STANDARD'\n    | 'REDUCED_REDUNDANCY'\n    | 'GLACIER'\n    | 'STANDARD_IA'\n    | 'INTELLIGENT_TIERING'\n    | 'DEEP_ARCHIVE'\n    | 'OUTPOSTS'\n    | 'GLACIER_IR'\n    | undefined\n","import { JSONArray, JSONObject } from 'k6'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { v4 as uuidv4 } from 'uuid'\nimport { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { AMZ_TARGET_HEADER } from './constants'\nimport { AWSError } from './error'\nimport { HTTPHeaders, HTTPMethod } from './http'\nimport { InvalidSignatureError, SignatureV4 } from './signature'\n\n/**\n * Class allowing to interact with Amazon AWS's SecretsManager service\n */\nexport class SecretsManagerClient extends AWSClient {\n    /**\n     * HTTP Method to use when interacting with the Secrets Manager service.\n     */\n    method: HTTPMethod\n\n    /**\n     * HTTP headers to use accross all requests to the Secrets Manager service.\n     */\n    commonHeaders: HTTPHeaders\n\n    signature: SignatureV4\n\n    /**\n     * Create a SecretsManagerClient\n     * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'secretsmanager')\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: awsConfig.region,\n            credentials: {\n                accessKeyId: awsConfig.accessKeyID,\n                secretAccessKey: awsConfig.secretAccessKey,\n            },\n            uriEscapePath: false,\n            applyChecksum: false,\n        })\n\n        // All interactions with the Secrets Manager service\n        // are made via the GET or POST method.\n        this.method = 'POST'\n        this.commonHeaders = {\n            'Content-Type': 'application/x-amz-json-1.1',\n        }\n    }\n\n    /**\n     * Returns a list of all secrets owned by the authenticated sender of the request.\n     * To use this operation, you must have the secretsmanager:ListSecrets permission.\n     *\n     * @return  {Array.<Secret>} secrets - An array of objects describing Secret Manager's secrets\n     * @throws  {SecretsManagerServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    listSecrets(): Array<Secret> {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `${this.serviceName}.ListSecrets`,\n                },\n                body: JSON.stringify({}),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(SecretsManagerOperation.ListSecrets, res)\n        const json: JSONArray = res.json('SecretList') as JSONArray\n\n        return json.map((s) => Secret.fromJSON(s as JSONObject))\n    }\n\n    /**\n     * Retrieves a secret from Amazon Sercets Manager\n     *\n     * @param {string} id - The ARN or name of the secret to retrieve.\n     * @returns {Secret} - returns the content of the fetched Secret object.\n     * @throws {SecretsManagerServiceError}\n     * @throws {InvalidSignatureError}\n     */\n    getSecret(id: string): Secret | undefined {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `${this.serviceName}.GetSecretValue`,\n                },\n                body: JSON.stringify({ SecretId: id }),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n\n        this._handle_error(SecretsManagerOperation.GetSecretValue, res)\n\n        return Secret.fromJSON(res.json() as JSONObject)\n    }\n\n    /**\n     * Creates a new secret\n     *\n     * Note that this method only supports string-based values at the moment.\n     *\n     * @param  {string} name - The name of the new secret.\n     *     The secret name can contain ASCII letters, numbers, and the following characters: /_+=.@\n     * @param  {string} secret - The text data to encrypt and store in this new version of the secret.\n     * @param  {string} description - The description of the secret.\n     * @param  {string} versionID=null - Version of the secret. This value helps ensure idempotency.\n     *     As a default, if no versionID is provided, one will be created for you using the UUID v4\n     *     algorithm.\n     * @param  {Array.<Object>} tags=[] - A list of tags to attach to the secret. Each tag is a key and\n     *     value pair of strings in a JSON text string. Note that tag key names are case sensitive.\n     * @returns {Secret} - returns the created secret\n     * @throws {SecretsManagerServiceError}\n     * @throws {InvalidSignatureError}\n     */\n    createSecret(\n        name: string,\n        secret: string,\n        description: string,\n        versionID?: string,\n        tags?: Array<Object>\n    ): Secret {\n        versionID = versionID || uuidv4()\n\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `${this.serviceName}.CreateSecret`,\n                },\n                body: JSON.stringify({\n                    Name: name,\n                    Description: description,\n                    SecretString: secret,\n                    ClientRequestToken: versionID,\n                    Tags: tags,\n                }),\n            },\n            {}\n        )\n\n        // Ensure to include the desired 'Action' in the X-Amz-Target\n        // header field, as documented by the AWS API docs.\n        // headers['X-Amz-Target'] = `${this.serviceName}.CreateSecret`\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(SecretsManagerOperation.CreateSecret, res)\n\n        return Secret.fromJSON(res.json() as JSONObject)\n    }\n    /**\n     * Update a secret's value.\n     *\n     * Note that this method only support string-based values at the moment.\n     *\n     * @param  {string} id - The ARN or name of the secret to update.\n     * @param  {string} secret - The text data to encrypt and store in this new version of the secret.\n     * @param  {} versionID=null  - A unique identifier for the new version of the secret. This value helps ensure idempotency.\n     *     As a default, if no versionID is provided, one will be created for you using the UUID v4\n     * @throws {SecretsManagerServiceError}\n     * @throws {InvalidSignatureError}\n     */\n    putSecretValue(id: string, secret: string, versionID?: string): Secret {\n        versionID = versionID || uuidv4()\n\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `${this.serviceName}.PutSecretValue`,\n                },\n                body: JSON.stringify({\n                    SecretId: id,\n                    SecretString: secret,\n                    ClientRequestToken: versionID,\n                }),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(SecretsManagerOperation.PutSecretValue, res)\n\n        return Secret.fromJSON(res.json() as JSONObject)\n    }\n\n    /**\n     * Deletes a secret and all of its versions.\n     *\n     * You can specify a recovery window during which you can restore the secret.\n     * The minimum recovery window is 7 days. The default recovery window is 30 days.\n     *\n     * @param {string} secretID - The ARN or name of the secret to delete.\n     * @param {number} recoveryWindow - The number of days from 7 to 30 that Secrets Manager\n     *     waits before permanently deleting the secret.\n     * @throws {SecretsManagerServiceError}\n     * @throws {InvalidSignatureError}\n     */\n    deleteSecret(\n        id: string,\n        { recoveryWindow = 30, noRecovery = false }: { recoveryWindow: number; noRecovery: boolean }\n    ) {\n        const payload: { [key: string]: string | boolean | number } = {\n            SecretId: id,\n        }\n\n        // noRecovery and recoveryWindow are exclusive parameters\n        if (noRecovery === true) {\n            payload['ForceDeleteWithoutRecovery'] = true\n        } else {\n            payload['RecoveryWindowInDays'] = recoveryWindow\n        }\n\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `${this.serviceName}.DeleteSecret`,\n                },\n                body: JSON.stringify(payload),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(SecretsManagerOperation.DeleteSecret, res)\n    }\n\n    _handle_error(\n        operation: SecretsManagerOperation,\n        response: RefinedResponse<ResponseType | undefined>\n    ) {\n        const errorCode = response.error_code\n        if (errorCode === 0) {\n            return\n        }\n\n        const error = response.json() as JSONObject\n        if (errorCode >= 1400 && errorCode <= 1499) {\n            // In the event of certain errors, the message is not set.\n            // Also, note the inconsistency in casing...\n            const errorMessage: string =\n                (error.Message as string) || (error.message as string) || (error.__type as string)\n\n            // Handle specifically the case of an invalid signature\n            if (error.__type === 'InvalidSignatureException') {\n                throw new InvalidSignatureError(errorMessage, error.__type)\n            }\n\n            // Otherwise throw a standard service error\n            throw new SecretsManagerServiceError(errorMessage, error.__type as string, operation)\n        }\n\n        if (errorCode === 1500) {\n            throw new SecretsManagerServiceError(\n                'An error occured on the server side',\n                'InternalServiceError',\n                operation\n            )\n        }\n    }\n}\n\n// TODO: create a Tags type\n\n/**\n * Class representing a Secret Manager's secret\n */\nexport class Secret {\n    name: string\n    arn: string\n    secret: string\n    createdDate: number\n    lastAccessedDate: number\n    lastChangedDate: number\n    tags: Array<{ [key: string]: string }>\n\n    /**\n     * Constructs a Secret Manager's Secret\n     *\n     * @param  {string} name - The friendly name of the secret.\n     * @param  {string} arn - The ARN of the secret.\n     * @param  {number} createdDate - The date and time that this version of the secret was created.\n     * @param  {number} lastAccessedDate - The last date that this secret was accessed. This value is\n     *     truncated to midnight of the date and therefore shows only the date, not the time.\n     * @param  {number} lastChangedDate - The last date and time that this secret was modified in any way.\n     * @param  {Array.<Object>} tags - The list of user-defined tags associated with the secret.\n     */\n    constructor(\n        name: string,\n        arn: string,\n        secretString: string,\n        createdDate: number,\n        lastAccessedDate: number,\n        lastChangedDate: number,\n        tags: Array<{ [key: string]: string }> = []\n    ) {\n        this.name = name\n        this.arn = arn\n        this.secret = secretString\n        this.createdDate = createdDate\n        this.lastAccessedDate = lastAccessedDate\n        this.lastChangedDate = lastChangedDate\n        this.tags = tags\n    }\n\n    /**\n     * Parses and constructs a Secret Manager's Secret from the content\n     * of a JSON response returned by the AWS service\n     *\n     * @param  {Object} json - JSON object as returned and parsed from\n     *     the AWS service's API call.\n     * @returns {Secret}\n     */\n    static fromJSON(json: JSONObject) {\n        return new Secret(\n            json.Name as string,\n            json.ARN as string,\n            json.SecretString as string,\n            json.CreatedDate as number,\n            json.LastAccessedDate as number,\n            json.LastChangedDate as number,\n            json.Tags as Array<{ [key: string]: string }>\n        )\n    }\n}\n\nexport class SecretsManagerServiceError extends AWSError {\n    operation: SecretsManagerOperation\n\n    /**\n     * Constructs a SecretsManagerServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: SecretsManagerOperation) {\n        super(message, code)\n        this.name = 'SecretsManagerServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n *  SecretsManagerOperation defines all currently implemented Secrets Manager Service operations.\n */\nenum SecretsManagerOperation {\n    ListSecrets = 'ListSecrets',\n    GetSecretValue = 'GetSecretValue',\n    CreateSecret = 'CreateSecret',\n    PutSecretValue = 'PutSecretValue',\n    DeleteSecret = 'DeleteSecret',\n}\n","import { JSONObject } from 'k6'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { AWSClient } from './client'\nimport { AWSConfig } from './config'\nimport { AMZ_TARGET_HEADER } from './constants'\nimport { AWSError } from './error'\nimport { HTTPHeaders, HTTPMethod } from './http'\nimport { InvalidSignatureError, SignatureV4 } from './signature'\n\n/**\n * Class allowing to interact with Amazon AWS's Systems Manager service\n */\nexport class SystemsManagerClient extends AWSClient {\n    method: HTTPMethod\n    commonHeaders: HTTPHeaders\n    signature: SignatureV4\n\n    /**\n     * Create a SystemsManagerClient\n     * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'ssm')\n\n        // All interactions with the Systems Manager service\n        // are made via the POST method.\n        this.method = 'POST'\n        this.commonHeaders = {\n            'Content-Type': 'application/x-amz-json-1.1',\n        }\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: awsConfig.region,\n            credentials: {\n                accessKeyId: awsConfig.accessKeyID,\n                secretAccessKey: awsConfig.secretAccessKey,\n            },\n            uriEscapePath: false,\n            applyChecksum: false,\n        })\n    }\n\n    /**\n     * Retrieves a parameter from Amazon Systems Manager\n     *\n     * @param {string} name - The ARN or name of the parameter to retrieve.\n     * @param {boolean} withDecryption - whether returned secure string parameters should be decrypted.\n     * @returns {SystemsManagerParameter} - returns the fetched Parameter object.\n     * @throws {SystemsManagerServiceError}\n     * @throws {InvalidSignatureError}\n     */\n    getParameter(\n        name: string,\n        withDecryption: boolean = false\n    ): SystemsManagerParameter | undefined {\n        const signedRequest = this.signature.sign(\n            {\n                method: this.method,\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `AmazonSSM.GetParameter`,\n                },\n                body: JSON.stringify({ Name: name, WithDecryption: withDecryption }),\n            },\n            {}\n        )\n\n        const res = http.request(this.method, signedRequest.url, signedRequest.body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(SystemsManagerOperation.GetParameter, res)\n\n        return SystemsManagerParameter.fromJSON(res.json() as JSONObject)\n    }\n\n    _handle_error(\n        operation: SystemsManagerOperation,\n        response: RefinedResponse<ResponseType | undefined>\n    ) {\n        const errorCode = response.error_code\n        if (errorCode === 0) {\n            return\n        }\n\n        const error = response.json() as JSONObject\n        if (errorCode >= 1400 && errorCode <= 1499) {\n            // In the event of certain errors, the message is not set.\n            // Also, note the inconsistency in casing...\n            const errorMessage: string =\n                (error.Message as string) || (error.message as string) || (error.__type as string)\n\n            // Handle specifically the case of an invalid signature\n            if (error.__type === 'InvalidSignatureException') {\n                throw new InvalidSignatureError(errorMessage, error.__type)\n            }\n\n            // Otherwise throw a standard service error\n            throw new SystemsManagerServiceError(errorMessage, error.__type as string, operation)\n        }\n\n        if (errorCode === 1500) {\n            throw new SystemsManagerServiceError(\n                'An error occured on the server side',\n                'InternalServiceError',\n                operation\n            )\n        }\n    }\n}\n\n/**\n * Class representing a Systems Manager's Parameter\n */\nexport class SystemsManagerParameter {\n    /**\n     * The Amazon Resource Name (ARN) of the parameter.\n     */\n    arn: string\n\n    /**\n     * The data type of the parameter, such as text or aws:ec2:image.\n     * The default is text.\n     */\n    dataType: string\n\n    /**\n     * Date the parameter was last changed or updated and the parameter version was created.\n     */\n    lastModifiedDate: number\n\n    /**\n     * The friendly name of the parameter.\n     */\n    name: string\n\n    /**\n     * Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats:\n     *  parameter_name:version\n     *  parameter_name:label\n     */\n    selector: string\n\n    /**\n     * plies to parameters that reference information in other AWS services. SourceResult is the raw result or response from the source.\n     */\n    sourceResult: string\n\n    /**\n     * The type of parameter. Valid values include the following: String, StringList, and SecureString.\n     */\n    type: string\n\n    /**\n     * The parameter value.\n     */\n    value: string\n\n    /**\n     * The parameter version.\n     */\n    version: number\n\n    /**\n     * Constructs a Systems Manager's Parameter\n     *\n     * @param  {string} arn - The Amazon Resource Name (ARN) of the parameter.\n     * @param  {string} dataType - The data type of the parameter, such as text or aws:ec2:image. The default is text.\n     * @param  {number} lastModifiedDate - Date the parameter was last changed or updated and the parameter version was created.\n     * @param  {string} name - The friendly name of the parameter.\n     * @param  {string} selector - Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats:\n     *  parameter_name:version\n     *  parameter_name:label\n     * @param  {string} sourceResult - Applies to parameters that reference information in other AWS services. SourceResult is the raw result or response from the source.\n     * @param  {string} type - The type of parameter. Valid values include the following: String, StringList, and SecureString.\n     * @param  {string} value - The parameter value.\n     * @param  {number} version - The parameter version.\n     */\n    constructor(\n        arn: string,\n        dataType: string,\n        lastModifiedDate: number,\n        name: string,\n        selector: string,\n        sourceResult: string,\n        type: string,\n        value: string,\n        version: number\n    ) {\n        this.arn = arn\n        this.dataType = dataType\n        this.lastModifiedDate = lastModifiedDate\n        this.name = name\n        this.selector = selector\n        this.sourceResult = sourceResult\n        this.type = type\n        this.value = value\n        this.version = version\n    }\n\n    /**\n     * Parses and constructs a Systems Manager's Parameter from the content\n     * of a JSON response returned by the AWS service\n     *\n     * @param  {Object} json - JSON object as returned and parsed from\n     *     the AWS service's API call.\n     * @returns {SystemsManagerParameter}\n     */\n    static fromJSON(json: JSONObject): SystemsManagerParameter {\n        const parameter = json.Parameter as JSONObject\n\n        return new SystemsManagerParameter(\n            parameter.ARN as string,\n            parameter.DataType as string,\n            parameter.LastModifiedDate as number,\n            parameter.Name as string,\n            parameter.Selector as string,\n            parameter.SourceResult as string,\n            parameter.Type as string,\n            parameter.Value as string,\n            parameter.Version as number\n        )\n    }\n}\n\nexport class SystemsManagerServiceError extends AWSError {\n    operation: SystemsManagerOperation\n\n    /**\n     * Constructs a SystemsManagerServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {SystemsManagerOperation} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: SystemsManagerOperation) {\n        super(message, code)\n        this.name = 'SystemsManagerServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n *  SystemsManagerOperation defines all currently implemented Systems Manager operations.\n */\nenum SystemsManagerOperation {\n    GetParameter = 'GetParameter',\n}\n"],"names":["AWSClient","awsConfig","serviceName","this","undefined","_host","region","endpoint","host","AWSConfig","options","InvalidAWSConfigError","accessKeyId","length","secretAccessKey","sessionToken","scheme","message","Error","AMZ_ALGORITHM_QUERY_PARAM","AMZ_CREDENTIAL_QUERY_PARAM","AMZ_DATE_QUERY_PARAM","AMZ_EXPIRES_QUERY_PARAM","AMZ_SIGNATURE_QUERY_PARAM","AMZ_SIGNED_HEADERS_QUERY_PARAM","AMZ_TOKEN_QUERY_PARAM","AMZ_CONTENT_SHA256_HEADER","AMZ_DATE_HEADER","toLowerCase","AMZ_SIGNATURE_HEADER","AMZ_TARGET_HEADER","AMZ_TOKEN_HEADER","AUTHORIZATION_HEADER","GENERATED_HEADERS","HOST_HEADER","ALWAYS_UNSIGNABLE_HEADERS","authorization","connection","expect","from","pragma","referer","te","trailer","upgrade","KEY_TYPE_IDENTIFIER","SIGNING_ALGORITHM_IDENTIFIER","MAX_PRESIGNED_TTL","EMPTY_SHA256","UNSIGNED_PAYLOAD","AWSError","code","name","xmlDocument","doc","parseHTML","find","text","hasHeader","soughtHeader","headers","Object","keys","SignatureV4","service","credentials","uriEscapePath","applyChecksum","request","signingDate","Date","signingService","signingRegion","unsignableHeaders","Set","signableHeaders","formatDate","longDate","shortDate","scope","constants","hostname","headerName","ArrayBuffer","isView","body","buffer","payloadHash","crypto","canonicalHeaders","computeCanonicalHeaders","canonicalRequest","createCanonicalRequest","signingKey","deriveSigningKey","signature","calculateSignature","sort","join","url","protocol","path","query","serializeQueryParameters","originalRequest","expiresIn","unhoistableHeaders","InvalidSignatureError","moveHeadersToQuery","toString","computePayloadHash","sortedHeaders","sortedCanonicalHeaders","map","signedHeaders","method","computeCanonicalURI","computeCanonicalQuerystring","credentialScope","hashedCanonicalRequest","stringToSign","createStringToSign","kSecret","kDate","kRegion","kService","normalizedURISegments","split","URISegment","pop","push","leading","startsWith","URI","trailing","endsWith","normalizedURI","encodeURIComponent","replace","serialized","key","value","escapeURI","Array","isArray","slice","reduce","encoded","concat","filter","canonicalHeaderName","has","trim","isArrayBuffer","requestCopy","JSON","parse","stringify","lowerCaseName","ignoreKeys","includes","c","charCodeAt","toUpperCase","date","time","Number","toDate","toISOString","prototype","call","toFormUrlEncoded","form","params","API_VERSION","SQSClient","commonHeaders","queueUrl","messageBody","Action","Version","QueueUrl","MessageBody","messageDeduplicationId","MessageDeduplicationId","messageGroupId","MessageGroupId","signedRequest","sign","res","http","_handleError","parsed","html","Message","parameters","maxResults","MaxResults","nextToken","NextToken","queueNamePrefix","QueueNamePrefix","urls","toArray","e","response","errorCode","error_code","error","id","bodyMD5","v1","v4","uuid","module","exports","byteToHex","i","substr","buf","offset","bth","getRandomValues","bind","window","msCrypto","rnds8","Uint8Array","rnds","r","Math","random","_nodeId","_clockseq","rng","bytesToUuid","_lastMSecs","_lastNSecs","b","node","clockseq","seedBytes","msecs","getTime","nsecs","dt","tl","tmh","n","ii","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","obj","prop","hasOwnProperty","Symbol","toStringTag","KMSOperation","KMSKeySize","KMSClient","accessKeyID","_handle_error","ListKeys","json","k","KMSKey","fromJSON","size","Size256","KeyId","NumberOfBytes","GenerateDataKey","KMSDataKey","operation","errorMessage","__type","KMSServiceError","keyArn","keyId","KeyArn","CiphertextBlob","Plaintext","ciphertextBlob","plaintext","S3Client","buckets","children","each","_","bucketDefinition","bucket","forEach","child","nodeName","assign","textContent","creationDate","bucketName","prefix","objects","objectDefinition","lastModified","etag","parseInt","storageClass","objectKey","S3Object","data","S3ServiceError","awsError","S3Bucket","SecretsManagerOperation","SecretsManagerClient","ListSecrets","s","Secret","SecretId","GetSecretValue","secret","description","versionID","tags","uuidv4","Name","Description","SecretString","ClientRequestToken","Tags","CreateSecret","PutSecretValue","recoveryWindow","noRecovery","payload","DeleteSecret","SecretsManagerServiceError","arn","secretString","createdDate","lastAccessedDate","lastChangedDate","ARN","CreatedDate","LastAccessedDate","LastChangedDate","SystemsManagerOperation","SystemsManagerClient","withDecryption","WithDecryption","GetParameter","SystemsManagerParameter","SystemsManagerServiceError","dataType","lastModifiedDate","selector","sourceResult","type","version","parameter","Parameter","DataType","LastModifiedDate","Selector","SourceResult","Type","Value"],"sourceRoot":""}