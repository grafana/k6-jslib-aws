{"version":3,"file":"_signature.min.js","mappings":"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","sources":["webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/error.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/html\");","import crypto, { hmac, sha256 } from 'k6/crypto'\nimport { HTTPMethod, HTTPHeaders } from './http'\nimport { AWSConfig } from './config'\nimport { AWSError } from './error'\n\n/**\n * Includes AWS v4 signing information to the provided HTTP headers object.\n *\n * This function will compute the `Authorization` header signature for the\n * provided request components, and add it to `header`. It will do so by following\n * the procedure detailled AWS' API docs: https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n *\n * The resulting `Authorization` header value is computed for the provided\n * headers object. Thus, any modification of the headers past a call to `signHeaders`\n * would effectively invalidate their signature, and the function should be\n * called again to recompute it.\n *\n * @param  {object} headers - HTTP headers request to sign.\n * @param  {number} requestTimestamp - Timestamp of the request\n * @param  {string} method - HTTP method used\n * @param  {string} path - HTTP request URL's path\n * @param  {string} queryString - HTTP request URL's querystring\n * @param  {string | ArrayBuffer} body - HTTP request's payload\n * @param  {AWSConfig} - AWS configuration\n * @param  {string} service - AWS service name\n * @param  {URIEncodingConfig} - URI encoding configuration\n */\nexport function signHeaders(\n    headers: HTTPHeaders,\n    requestTimestamp: number,\n    method: HTTPMethod,\n    path: string,\n    queryString: string,\n    body: string | ArrayBuffer,\n    awsConfig: AWSConfig,\n    service: string,\n    URIencodingConfig: URIEncodingConfig\n): HTTPHeaders {\n    // If the config contains a session token, we should add it to the headers\n    // as a `X-Amz-Security-Token` header, cf: https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    if (awsConfig.sessionToken) {\n        headers['X-Amz-Security-Token'] = awsConfig.sessionToken\n    }\n\n    const derivedSigningKey = deriveSigningKey(\n        awsConfig.secretAccessKey,\n        requestTimestamp,\n        awsConfig.region,\n        service\n    )\n\n    const canonicalRequest = createCanonicalRequest(\n        method,\n        path,\n        queryString,\n        headers,\n        body,\n        URIencodingConfig\n    )\n\n    const stringToSign = createStringToSign(\n        requestTimestamp,\n        awsConfig.region,\n        service,\n        sha256(canonicalRequest, 'hex')\n    )\n\n    const credentialScope = createCredentialScope(requestTimestamp, awsConfig.region, service)\n    const signedHeaders = createSignedHeaders(headers)\n    const signature = calculateSignature(derivedSigningKey, stringToSign)\n    const authorizationHeader = `${HashingAlgorithm} Credential=${awsConfig.accessKeyID}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`\n\n    headers['Authorization'] = authorizationHeader\n\n    return headers\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\n/**\n * Calculte the signature for AWS signature version 4\n *\n * @param  {string} derivedSigningKey - dervied signing key as computed by `deriveSigningKey`\n * @param  {string} stringToSign - String to sign as computed by `createStringToSign`\n * @return {string}\n */\nexport function calculateSignature(derivedSigningKey: ArrayBuffer, stringToSign: string): string {\n    return hmac('sha256', derivedSigningKey, stringToSign, 'hex')\n}\n/**\n * Derives the signing key for authenticating requests signed with\n * the Signature version 4 authentication protocol.\n *\n * deriveSigningKey produces a signing key by creating a series of\n * hash-based message authentication codes (HMACs) represented in\n * a binary format.\n *\n * The derived signing key is specific to the date it's made at, as well as\n * the service and region it targets.\n *\n * @param  {string} secretAccessKey - the AWS secret access key to derive the signing key for\n * @param  {number} time - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service. MUST be UTF-8 encoded.\n * @return {string}\n */\nexport function deriveSigningKey(\n    secretAccessKey: string,\n    time: number,\n    region: string,\n    service: string\n): ArrayBuffer {\n    const kSecret = secretAccessKey\n    const date = toDate(time)\n\n    // FIXME: hmac takes ArrayBuffer as input, but returns bytes (number[]).\n    // How does one convert from one to the other?\n    const kDate: any = hmac('sha256', 'AWS4' + kSecret, date, 'binary')\n    const kRegion: any = hmac('sha256', kDate, region, 'binary')\n    const kService: any = hmac('sha256', kRegion, service, 'binary')\n    const kSigning: any = hmac('sha256', kService, 'aws4_request', 'binary')\n\n    return kSigning\n}\n\n// Hashing Algorithm to use in the signature process\nexport const HashingAlgorithm = 'AWS4-HMAC-SHA256'\n\n/**\n * Certain services, such as S3, allow for unsigned payloads. If\n *  producing a signed canonical request for such service, pass\n *  the `UnsignedPayload` constant value as the payload parameter.\n */\nexport const UnsignedPayload = 'UNSIGNED-PAYLOAD'\n\n/**\n * Create the \"string to sign\" part of the signature Version 4 protocol.\n *\n * The \"string to sign\" includes meta information about your request and\n * about the canonical request that you created with `createCanonicalRequest`.\n * It is used hand in hand with the signing key to create the request signature.\n *\n * @param  {number} requestTimestamp - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service name. MUST be UTF-8 encoded.\n * @param  {string} hashedCanonicalRequest - canonical request as produced by calling the createCanonicalRequest function,\n *     hashed using the SHA256 algorithm (encoded in hexadecimal format).\n * @return {string}\n */\nexport function createStringToSign(\n    requestTimestamp: number,\n    region: string,\n    service: string,\n    hashedCanonicalRequest: string\n): string {\n    // the request date specified in ISO8601 format: YYYYMMDD'T'HHMMSS'Z'\n    const requestDateTime = toTime(requestTimestamp)\n\n    // The credential scope value, consisting of the date in YYYYMMDD format,\n    // the targeted region, the targeted service, and a termination string.\n    // Note that the region and service MUST be UTF-8 encoded.\n    const credentialScope = createCredentialScope(requestTimestamp, region, service)\n\n    const stringToSign = [\n        // Algorithm\n        HashingAlgorithm,\n\n        // RequestDateTime\n        requestDateTime,\n\n        // CredentialScope\n        credentialScope,\n\n        // HashedCanonicalRequest\n        hashedCanonicalRequest,\n    ].join('\\n')\n\n    return stringToSign\n}\n\n/**\n *\n * Helper function creating a credential scope string to use in the signature\n * version 4 process. A credential scope consists of the date of the request\n * in YYYYMMDD format, the targeted region, the targeted service, and a\n * termination string.\n *\n * Note that the region and service MUST be UTF-8 encoded.\n *\n * @param  {number} requestTimestamp - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service name. MUST be UTF-8 encoded.\n * @return {string}\n */\nexport function createCredentialScope(\n    requestTimestamp: number,\n    region: string,\n    service: string\n): string {\n    return [toDate(requestTimestamp), region, service, 'aws4_request'].join('/')\n}\n\n/**\n *  Create a string that includes information from your request\n * in a AWS signature v4 standardized (canonical) format.\n *\n * @param  {string} method - the HTTP request method\n * @param  {string} uri - URI-encoded version of the absolute path component of the URI\n * @param  {string} query - request's query string\n * @param  {Object} headers - all the HTTP headers that you wish to include with the signed request\n * @param  {string | ArrayBuffer} payload -  payload to include as the body of the request\n * @param  {URIEncodingConfig} URIencodingConfig- URI encoding configuration\n * @return {string}\n */\nexport function createCanonicalRequest(\n    method: HTTPMethod,\n    uri: string,\n    query: string,\n    headers: HTTPHeaders,\n    payload: string | ArrayBuffer,\n    URIencodingConfig: URIEncodingConfig\n): string {\n    const httpRequestMethod = method.toUpperCase()\n    const canonicalURI = createCanonicalURI(uri, URIencodingConfig)\n    const canonicalQueryString = createCanonicalQueryString(query)\n    const canonicalHeaders = createCanonicalHeaders(headers)\n    const signedHeaders = createSignedHeaders(headers)\n    const requestPayload = createCanonicalPayload(payload)\n\n    const canonicalRequest = [\n        httpRequestMethod,\n        canonicalURI,\n        canonicalQueryString,\n        canonicalHeaders,\n        signedHeaders,\n        requestPayload,\n    ].join('\\n')\n\n    return canonicalRequest\n}\n\n/**\n *  Creates the (canonical) URI-encoded version of the\n *  absolute path component of the URI: everything in the URI\n *  from the HTTP host to the question mark character (\"?\")\n *  that begins the query string parameters (if any).\n *\n * @param  {string} uri - URI to canonize\n * @param  {URIEncodingConfig} - URI encoding configuration\n * @return {string} - canonical URL\n */\nexport function createCanonicalURI(uri: string, URIencodingConfig: URIEncodingConfig): string {\n    if (uri == '/') {\n        return uri\n    }\n\n    let canonicalURI = uri\n    if (uri[uri.length - 1] == '/' && canonicalURI[canonicalURI.length - 1] != '/') {\n        canonicalURI += '/'\n    }\n\n    canonicalURI = URIEncode(canonicalURI, URIencodingConfig.path)\n\n    return URIencodingConfig.double ? URIEncode(canonicalURI, URIencodingConfig.path) : canonicalURI\n}\n\n/**\n * Creates the canonical form of the request's query\n * string. If the request does not include a query string,\n * provide an empty string.\n *\n * @param  {String | Object} qs - query string to canonize\n * @return {string}\n */\nexport function createCanonicalQueryString(qs: string): string {\n    if (qs === '') {\n        return ''\n    }\n\n    // const intermediary: { [key: string]: string } = parseQueryString(qs)\n\n    // return Object.keys(intermediary)\n    //     .sort()\n    //     .map((key: string) => {\n    //         // const values: string[] = Array.isArray(intermediary[key])\n    //         //     ? intermediary[key]\n    //         //     : [intermediary[key]]\n    //         const values = intermediary[key]\n\n    //         return values\n    //             .sort()\n    //             .map((val: string) => encodeURIComponent(key) + '=' + encodeURIComponent(val))\n    //             .join('&')\n    //     })\n    //     .join('&')\n\n    return parseQueryString(qs)\n        .map(([key, value]: [string, string]): string => {\n            let uriComponent = encodeURIComponent(key) + '='\n            if (value !== 'undefined') {\n                uriComponent += encodeURIComponent(value)\n            }\n\n            return uriComponent\n        })\n        .join('&')\n}\n\n/**\n * Create the canonical form of the request's headers.\n * Canonical headers consist of all the HTTP headers you\n * are including with the signed request.\n *\n * Note that:\n *   * for HTTP/1.1 requests, the headers should at least\n * contain the `host` header.\n *   * for HTTP/2, the `:authority` header must be used instead\n * of `host`.\n *\n * @param  {Object} headers\n * @return {string}\n */\nexport function createCanonicalHeaders(headers: HTTPHeaders) {\n    if (headers.constructor !== Object || Object.entries(headers).length === 0) {\n        return ''\n    }\n\n    const canonicalHeaders = Object.entries(headers)\n        .map(([name, values]) => {\n            const canonicalName = name.toLowerCase().trim()\n            const normalizedValues = Array.isArray(values) ? values : [values]\n\n            // Note that we do not need to sort values\n            const canonicalValues = normalizedValues\n                .map((v) => {\n                    // convert sequential spaces to a single space\n                    return v.replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '')\n                })\n                .join(',') // standard for multiple values in a HTTP header\n\n            return canonicalName + ':' + canonicalValues + '\\n'\n        })\n        .sort()\n        .join('')\n\n    return canonicalHeaders\n}\n\n/**\n * Create the canonical request's signed headers.\n *\n * The signed headers part of the request contains the\n * list of headers included in the request's signing process.\n *\n * Note that:\n *   * for HTTP/1.1 requests, the `host` header must be included.\n *   * for HTTP/2 requests, the `:authority` header must be included instead\n *   of host.\n *   * if used, the `x-amz-date` header must be included.\n *\n * @param  {Object} headers\n * @return {string}\n * @throws {TypeError} - on headers not being an Object, or being empty.\n */\nexport function createSignedHeaders(headers: { [key: string]: string }) {\n    if (headers.constructor !== Object) {\n        throw new TypeError('headers should be an object')\n    }\n\n    if (Object.entries(headers).length === 0) {\n        throw 'headers should at least contain either the Host (HTTP 1.1) or :authority (HTTP 2) parameter'\n    }\n\n    // To create the signed headers list, convert\n    // all header names to lowercase, sort them by\n    // character code, and use a semicolon to separate\n    // the header names.\n    const result = Object.keys(headers)\n        .map((name) => name.toLowerCase().trim())\n        .sort()\n        .join(';')\n\n    return result\n}\n\n/**\n * Create the canonical form of the request's payload.\n *\n * The canonical payload consists in a lowercased, hex encoded,\n * SHA256 hash of the requests body/payload.\n *\n * Certain services, such as S3, allow for unsigned payload. If\n * producing a signed canonical request for such service, pass\n * the `UnsignedPayload` constant value as the payload parameter.\n *\n * @param  {String | ArrayBuffer} payload\n * @return {string}\n */\nexport function createCanonicalPayload(payload: string | ArrayBuffer) {\n    if (payload === UnsignedPayload) {\n        return payload\n    }\n\n    // Note that if the paylaod is null, we convert it\n    // to an empty string.\n    // TODO: Should switching to empty string if null impact headers?\n    return crypto.sha256(payload || '', 'hex').toLowerCase()\n}\n\n/**\n * URIEncodes encodes every bytes of a URI to be URL-safe.\n *\n * This implementation is specific to AWS; who intended to make it as\n * close as possible to the underlying RFC 3946. It:\n *   * URI encode every byte except the unreserved characters: 'A'-'Z', 'a'-'z', '0'-'9',\n *     '-', '.', '_', and '~'.\n *   * considers the space character as a reserved character and must URI encodes\n *     encodes it as \"%20\" (and not as \"+\").\n *   * URI encodes every byte by prefixing with '%' the two-digit hexadecimal value of the byte.\n *   * If the `path` argument is set, forward slashes are not encoded, to fit with\n *     S3 requirements.\n *\n * N.B: this implementation differs with ES6' mainly in that it does\n * encode the \"'\" character.\n *\n * Based on AWS implementation: https://github.com/aws/aws-sdk-java/blob/master/aws-java-sdk-core/src/main/java/com/amazonaws/util/SdkHttpUtils.java#L66\n * Encoding specs: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html\n *\n * @param {string} uri - uri to encode\n * @param {boolean} path - slash characters should be encoded everywhere,\n *     but in paths, set to false when encoding a path\n * @return {string} the URI encoded result\n */\nexport function URIEncode(uri: string, path: boolean): string {\n    if (uri == '') {\n        return uri\n    }\n\n    return uri\n        .split('') // to be able to map over a string, because... javascript...\n        .map((letter: string) => {\n            if (isAlpha(letter) || isNumeric(letter) || '-._~'.includes(letter)) {\n                return letter\n            }\n\n            // Space should be explicitly encoded to as %20.\n            if (letter == ' ') {\n                return '%20'\n            }\n\n            // If the URI is a path, the forward slash shouldn't\n            // be encoded.\n            if (letter == '/' && path) {\n                return '/'\n            }\n\n            return '%' + letter.charCodeAt(0).toString(16).toUpperCase()\n        })\n        .join('')\n}\n\n/**\n * Class holding URI encoding configuration\n */\nexport class URIEncodingConfig {\n    double: boolean\n    path: boolean\n\n    /**\n     *\n     * @param {boolean} double - should the URI be double encoded?\n     * @param {boolean} path - is the URI a path? If so, its forward\n     *     slashes won't be URIencoded.\n     */\n    constructor(double: boolean, path: boolean) {\n        this.double = double\n        this.path = path\n    }\n}\n\n/**\n * Compute the request time value as specified by the ISO8601\n * format: YYYYMMDD'T'HHMMSS'Z'\n *\n * @param  {number} timestamp\n * @return {string}\n */\nexport function toTime(timestamp: number): string {\n    return new Date(timestamp).toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n}\n/**\n * Computethe request date value in the format: YYYMMDD\n *\n * @param  {number} timestamp\n * @return {string}\n */\nexport function toDate(timestamp: number): string {\n    return toTime(timestamp).substring(0, 8)\n}\n\n/**\n * Parse a HTTP request URL's querystring into an object\n * containing its `key=value` pairs.\n *\n * @param  {string} qs\n * @return {object}\n */\nexport function parseQueryString(qs: string): Array<[string, string]> {\n    if (qs.length === 0) {\n        return []\n    }\n\n    return qs\n        .split('&')\n        .filter((e) => e)\n        .map((v: string): [string, string] => {\n            const parts = v.split('=', 2) as [string, string]\n            const key = decodeURIComponent(parts[0])\n            let value = decodeURIComponent(parts[1])\n            if (value === 'undefined') {\n                value = ''\n            }\n            return [key, value]\n        })\n        .sort((a: [string, string], b: [string, string]) => {\n            return a[0].localeCompare(b[0])\n        })\n}\n\nfunction isAlpha(c: string): boolean {\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')\n}\n\nfunction isNumeric(c: string): boolean {\n    return c >= '0' && c <= '9'\n}\n\n// FIXME: finish implementation when needed\n// See the following for more details:\n//   * https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n//   * https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n// export function signQueryString(\n// queryString,\n// requestTimestamp,\n// accessKeyID,\n// secretAccessKey,\n// region,\n// service,\n// ttl, // in seconds\n// headers,\n// doubleURIEncoding = true\n// ) {\n// const credential = [accessKeyID, toDate(requestTimestamp), region, service].join('/')\n//\n// const canonicalRequest = createCanonicalRequest(\n// method,\n// path,\n// queryString,\n// headers,\n// body,\n// doubleURIEncoding\n// )\n//\n// const derivedSigningKey = deriveSigningKey(secretAccessKey, requestTimestamp, region, service)\n//\n// const stringToSign = createStringToSign(\n// requestTimestamp,\n// region,\n// service,\n// sha256(canonicalRequest, 'hex')\n// )\n//\n// const signedHeaders = createSignedHeaders(headers)\n// const signature = calculateSignature(derivedSigningKey, stringToSign)\n//\n// return [\n// `X-Amz-Algorithm=${HashingAlgorithm}`,\n// `X-Amz-Credential=${crediental}`,\n// `X-Amz-Date=${toTime(requestTimestamp)}`,\n// `X-Amz-Expires=${ttl}`,\n// `X-Amz-SignedHeaders=${signedHeaders}`,\n// `X-Amz-Signature=${signature}`,\n//`X-Amz-Security-Token=`,  // TODO: optional\n// ].join('&')\n// }\n","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    code: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","signHeaders","headers","requestTimestamp","method","path","queryString","body","awsConfig","service","URIencodingConfig","sessionToken","derivedSigningKey","deriveSigningKey","secretAccessKey","region","canonicalRequest","createCanonicalRequest","stringToSign","createStringToSign","sha256","credentialScope","createCredentialScope","signedHeaders","createSignedHeaders","signature","calculateSignature","authorizationHeader","HashingAlgorithm","accessKeyID","InvalidSignatureError","message","code","name","xmlDocument","doc","parseHTML","AWSError","find","text","Error","hmac","time","kSecret","date","toDate","kDate","kRegion","kService","UnsignedPayload","hashedCanonicalRequest","requestDateTime","toTime","join","uri","query","payload","toUpperCase","createCanonicalURI","createCanonicalQueryString","createCanonicalHeaders","createCanonicalPayload","canonicalURI","length","URIEncode","qs","parseQueryString","map","uriComponent","encodeURIComponent","constructor","entries","values","toLowerCase","trim","Array","isArray","v","replace","sort","TypeError","keys","crypto","split","letter","c","isNumeric","includes","charCodeAt","toString","URIEncodingConfig","double","this","timestamp","Date","toISOString","substring","filter","e","parts","decodeURIComponent","b","localeCompare"],"sourceRoot":""}