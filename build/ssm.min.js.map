{"version":3,"file":"ssm.min.js","mappings":"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","sources":["webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/./src/internal/error.ts","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/config.ts","webpack://k6-jslib-aws/external commonjs \"k6/http\"","webpack://k6-jslib-aws/./src/internal/ssm.ts","webpack://k6-jslib-aws/./src/internal/client.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/html\");","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    code: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n","import crypto, { hmac, sha256 } from 'k6/crypto'\nimport { HTTPMethod, HTTPHeaders } from './http'\nimport { AWSConfig } from './config'\nimport { AWSError } from './error'\n\n/**\n * Includes AWS v4 signing information to the provided HTTP headers object.\n *\n * This function will compute the `Authorization` header signature for the\n * provided request components, and add it to `header`. It will do so by following\n * the procedure detailled AWS' API docs: https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n *\n * The resulting `Authorization` header value is computed for the provided\n * headers object. Thus, any modification of the headers past a call to `signHeaders`\n * would effectively invalidate their signature, and the function should be\n * called again to recompute it.\n *\n * @param  {object} headers - HTTP headers request to sign.\n * @param  {number} requestTimestamp - Timestamp of the request\n * @param  {string} method - HTTP method used\n * @param  {string} path - HTTP request URL's path\n * @param  {string} queryString - HTTP request URL's querystring\n * @param  {string | ArrayBuffer} body - HTTP request's payload\n * @param  {AWSConfig} - AWS configuration\n * @param  {string} service - AWS service name\n * @param  {URIEncodingConfig} - URI encoding configuration\n */\nexport function signHeaders(\n    headers: HTTPHeaders,\n    requestTimestamp: number,\n    method: HTTPMethod,\n    path: string,\n    queryString: string,\n    body: string | ArrayBuffer,\n    awsConfig: AWSConfig,\n    service: string,\n    URIencodingConfig: URIEncodingConfig\n): HTTPHeaders {\n    // If the config contains a session token, we should add it to the headers\n    // as a `X-Amz-Security-Token` header, cf: https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    if (awsConfig.sessionToken) {\n        headers['X-Amz-Security-Token'] = awsConfig.sessionToken\n    }\n\n    const derivedSigningKey = deriveSigningKey(\n        awsConfig.secretAccessKey,\n        requestTimestamp,\n        awsConfig.region,\n        service\n    )\n\n    const canonicalRequest = createCanonicalRequest(\n        method,\n        path,\n        queryString,\n        headers,\n        body,\n        URIencodingConfig\n    )\n\n    const stringToSign = createStringToSign(\n        requestTimestamp,\n        awsConfig.region,\n        service,\n        sha256(canonicalRequest, 'hex')\n    )\n\n    const credentialScope = createCredentialScope(requestTimestamp, awsConfig.region, service)\n    const signedHeaders = createSignedHeaders(headers)\n    const signature = calculateSignature(derivedSigningKey, stringToSign)\n    const authorizationHeader = `${HashingAlgorithm} Credential=${awsConfig.accessKeyID}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`\n\n    headers['Authorization'] = authorizationHeader\n\n    return headers\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\n/**\n * Calculte the signature for AWS signature version 4\n *\n * @param  {string} derivedSigningKey - dervied signing key as computed by `deriveSigningKey`\n * @param  {string} stringToSign - String to sign as computed by `createStringToSign`\n * @return {string}\n */\nexport function calculateSignature(derivedSigningKey: ArrayBuffer, stringToSign: string): string {\n    return hmac('sha256', derivedSigningKey, stringToSign, 'hex')\n}\n/**\n * Derives the signing key for authenticating requests signed with\n * the Signature version 4 authentication protocol.\n *\n * deriveSigningKey produces a signing key by creating a series of\n * hash-based message authentication codes (HMACs) represented in\n * a binary format.\n *\n * The derived signing key is specific to the date it's made at, as well as\n * the service and region it targets.\n *\n * @param  {string} secretAccessKey - the AWS secret access key to derive the signing key for\n * @param  {number} time - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service. MUST be UTF-8 encoded.\n * @return {string}\n */\nexport function deriveSigningKey(\n    secretAccessKey: string,\n    time: number,\n    region: string,\n    service: string\n): ArrayBuffer {\n    const kSecret = secretAccessKey\n    const date = toDate(time)\n\n    // FIXME: hmac takes ArrayBuffer as input, but returns bytes (number[]).\n    // How does one convert from one to the other?\n    const kDate: any = hmac('sha256', 'AWS4' + kSecret, date, 'binary')\n    const kRegion: any = hmac('sha256', kDate, region, 'binary')\n    const kService: any = hmac('sha256', kRegion, service, 'binary')\n    const kSigning: any = hmac('sha256', kService, 'aws4_request', 'binary')\n\n    return kSigning\n}\n\n// Hashing Algorithm to use in the signature process\nexport const HashingAlgorithm = 'AWS4-HMAC-SHA256'\n\n/**\n * Certain services, such as S3, allow for unsigned payloads. If\n *  producing a signed canonical request for such service, pass\n *  the `UnsignedPayload` constant value as the payload parameter.\n */\nexport const UnsignedPayload = 'UNSIGNED-PAYLOAD'\n\n/**\n * Create the \"string to sign\" part of the signature Version 4 protocol.\n *\n * The \"string to sign\" includes meta information about your request and\n * about the canonical request that you created with `createCanonicalRequest`.\n * It is used hand in hand with the signing key to create the request signature.\n *\n * @param  {number} requestTimestamp - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service name. MUST be UTF-8 encoded.\n * @param  {string} hashedCanonicalRequest - canonical request as produced by calling the createCanonicalRequest function,\n *     hashed using the SHA256 algorithm (encoded in hexadecimal format).\n * @return {string}\n */\nexport function createStringToSign(\n    requestTimestamp: number,\n    region: string,\n    service: string,\n    hashedCanonicalRequest: string\n): string {\n    // the request date specified in ISO8601 format: YYYYMMDD'T'HHMMSS'Z'\n    const requestDateTime = toTime(requestTimestamp)\n\n    // The credential scope value, consisting of the date in YYYYMMDD format,\n    // the targeted region, the targeted service, and a termination string.\n    // Note that the region and service MUST be UTF-8 encoded.\n    const credentialScope = createCredentialScope(requestTimestamp, region, service)\n\n    const stringToSign = [\n        // Algorithm\n        HashingAlgorithm,\n\n        // RequestDateTime\n        requestDateTime,\n\n        // CredentialScope\n        credentialScope,\n\n        // HashedCanonicalRequest\n        hashedCanonicalRequest,\n    ].join('\\n')\n\n    return stringToSign\n}\n\n/**\n *\n * Helper function creating a credential scope string to use in the signature\n * version 4 process. A credential scope consists of the date of the request\n * in YYYYMMDD format, the targeted region, the targeted service, and a\n * termination string.\n *\n * Note that the region and service MUST be UTF-8 encoded.\n *\n * @param  {number} requestTimestamp - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service name. MUST be UTF-8 encoded.\n * @return {string}\n */\nexport function createCredentialScope(\n    requestTimestamp: number,\n    region: string,\n    service: string\n): string {\n    return [toDate(requestTimestamp), region, service, 'aws4_request'].join('/')\n}\n\n/**\n *  Create a string that includes information from your request\n * in a AWS signature v4 standardized (canonical) format.\n *\n * @param  {string} method - the HTTP request method\n * @param  {string} uri - URI-encoded version of the absolute path component of the URI\n * @param  {string} query - request's query string\n * @param  {Object} headers - all the HTTP headers that you wish to include with the signed request\n * @param  {string | ArrayBuffer} payload -  payload to include as the body of the request\n * @param  {URIEncodingConfig} URIencodingConfig- URI encoding configuration\n * @return {string}\n */\nexport function createCanonicalRequest(\n    method: HTTPMethod,\n    uri: string,\n    query: string,\n    headers: HTTPHeaders,\n    payload: string | ArrayBuffer,\n    URIencodingConfig: URIEncodingConfig\n): string {\n    const httpRequestMethod = method.toUpperCase()\n    const canonicalURI = createCanonicalURI(uri, URIencodingConfig)\n    const canonicalQueryString = createCanonicalQueryString(query)\n    const canonicalHeaders = createCanonicalHeaders(headers)\n    const signedHeaders = createSignedHeaders(headers)\n    const requestPayload = createCanonicalPayload(payload)\n\n    const canonicalRequest = [\n        httpRequestMethod,\n        canonicalURI,\n        canonicalQueryString,\n        canonicalHeaders,\n        signedHeaders,\n        requestPayload,\n    ].join('\\n')\n\n    return canonicalRequest\n}\n\n/**\n *  Creates the (canonical) URI-encoded version of the\n *  absolute path component of the URI: everything in the URI\n *  from the HTTP host to the question mark character (\"?\")\n *  that begins the query string parameters (if any).\n *\n * @param  {string} uri - URI to canonize\n * @param  {URIEncodingConfig} - URI encoding configuration\n * @return {string} - canonical URL\n */\nexport function createCanonicalURI(uri: string, URIencodingConfig: URIEncodingConfig): string {\n    if (uri == '/') {\n        return uri\n    }\n\n    let canonicalURI = uri\n    if (uri[uri.length - 1] == '/' && canonicalURI[canonicalURI.length - 1] != '/') {\n        canonicalURI += '/'\n    }\n\n    canonicalURI = URIEncode(canonicalURI, URIencodingConfig.path)\n\n    return URIencodingConfig.double ? URIEncode(canonicalURI, URIencodingConfig.path) : canonicalURI\n}\n\n/**\n * Creates the canonical form of the request's query\n * string. If the request does not include a query string,\n * provide an empty string.\n *\n * @param  {String | Object} qs - query string to canonize\n * @return {string}\n */\nexport function createCanonicalQueryString(qs: string): string {\n    if (qs === '') {\n        return ''\n    }\n\n    // const intermediary: { [key: string]: string } = parseQueryString(qs)\n\n    // return Object.keys(intermediary)\n    //     .sort()\n    //     .map((key: string) => {\n    //         // const values: string[] = Array.isArray(intermediary[key])\n    //         //     ? intermediary[key]\n    //         //     : [intermediary[key]]\n    //         const values = intermediary[key]\n\n    //         return values\n    //             .sort()\n    //             .map((val: string) => encodeURIComponent(key) + '=' + encodeURIComponent(val))\n    //             .join('&')\n    //     })\n    //     .join('&')\n\n    return parseQueryString(qs)\n        .map(([key, value]: [string, string]): string => {\n            let uriComponent = encodeURIComponent(key) + '='\n            if (value !== 'undefined') {\n                uriComponent += encodeURIComponent(value)\n            }\n\n            return uriComponent\n        })\n        .join('&')\n}\n\n/**\n * Create the canonical form of the request's headers.\n * Canonical headers consist of all the HTTP headers you\n * are including with the signed request.\n *\n * Note that:\n *   * for HTTP/1.1 requests, the headers should at least\n * contain the `host` header.\n *   * for HTTP/2, the `:authority` header must be used instead\n * of `host`.\n *\n * @param  {Object} headers\n * @return {string}\n */\nexport function createCanonicalHeaders(headers: HTTPHeaders) {\n    if (headers.constructor !== Object || Object.entries(headers).length === 0) {\n        return ''\n    }\n\n    const canonicalHeaders = Object.entries(headers)\n        .map(([name, values]) => {\n            const canonicalName = name.toLowerCase().trim()\n            const normalizedValues = Array.isArray(values) ? values : [values]\n\n            // Note that we do not need to sort values\n            const canonicalValues = normalizedValues\n                .map((v) => {\n                    // convert sequential spaces to a single space\n                    return v.replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '')\n                })\n                .join(',') // standard for multiple values in a HTTP header\n\n            return canonicalName + ':' + canonicalValues + '\\n'\n        })\n        .sort()\n        .join('')\n\n    return canonicalHeaders\n}\n\n/**\n * Create the canonical request's signed headers.\n *\n * The signed headers part of the request contains the\n * list of headers included in the request's signing process.\n *\n * Note that:\n *   * for HTTP/1.1 requests, the `host` header must be included.\n *   * for HTTP/2 requests, the `:authority` header must be included instead\n *   of host.\n *   * if used, the `x-amz-date` header must be included.\n *\n * @param  {Object} headers\n * @return {string}\n * @throws {TypeError} - on headers not being an Object, or being empty.\n */\nexport function createSignedHeaders(headers: { [key: string]: string }) {\n    if (headers.constructor !== Object) {\n        throw new TypeError('headers should be an object')\n    }\n\n    if (Object.entries(headers).length === 0) {\n        throw 'headers should at least contain either the Host (HTTP 1.1) or :authority (HTTP 2) parameter'\n    }\n\n    // To create the signed headers list, convert\n    // all header names to lowercase, sort them by\n    // character code, and use a semicolon to separate\n    // the header names.\n    const result = Object.keys(headers)\n        .map((name) => name.toLowerCase().trim())\n        .sort()\n        .join(';')\n\n    return result\n}\n\n/**\n * Create the canonical form of the request's payload.\n *\n * The canonical payload consists in a lowercased, hex encoded,\n * SHA256 hash of the requests body/payload.\n *\n * Certain services, such as S3, allow for unsigned payload. If\n * producing a signed canonical request for such service, pass\n * the `UnsignedPayload` constant value as the payload parameter.\n *\n * @param  {String | ArrayBuffer} payload\n * @return {string}\n */\nexport function createCanonicalPayload(payload: string | ArrayBuffer) {\n    if (payload === UnsignedPayload) {\n        return payload\n    }\n\n    // Note that if the paylaod is null, we convert it\n    // to an empty string.\n    // TODO: Should switching to empty string if null impact headers?\n    return crypto.sha256(payload || '', 'hex').toLowerCase()\n}\n\n/**\n * URIEncodes encodes every bytes of a URI to be URL-safe.\n *\n * This implementation is specific to AWS; who intended to make it as\n * close as possible to the underlying RFC 3946. It:\n *   * URI encode every byte except the unreserved characters: 'A'-'Z', 'a'-'z', '0'-'9',\n *     '-', '.', '_', and '~'.\n *   * considers the space character as a reserved character and must URI encodes\n *     encodes it as \"%20\" (and not as \"+\").\n *   * URI encodes every byte by prefixing with '%' the two-digit hexadecimal value of the byte.\n *   * If the `path` argument is set, forward slashes are not encoded, to fit with\n *     S3 requirements.\n *\n * N.B: this implementation differs with ES6' mainly in that it does\n * encode the \"'\" character.\n *\n * Based on AWS implementation: https://github.com/aws/aws-sdk-java/blob/master/aws-java-sdk-core/src/main/java/com/amazonaws/util/SdkHttpUtils.java#L66\n * Encoding specs: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html\n *\n * @param {string} uri - uri to encode\n * @param {boolean} path - slash characters should be encoded everywhere,\n *     but in paths, set to false when encoding a path\n * @return {string} the URI encoded result\n */\nexport function URIEncode(uri: string, path: boolean): string {\n    if (uri == '') {\n        return uri\n    }\n\n    return uri\n        .split('') // to be able to map over a string, because... javascript...\n        .map((letter: string) => {\n            if (isAlpha(letter) || isNumeric(letter) || '-._~'.includes(letter)) {\n                return letter\n            }\n\n            // Space should be explicitly encoded to as %20.\n            if (letter == ' ') {\n                return '%20'\n            }\n\n            // If the URI is a path, the forward slash shouldn't\n            // be encoded.\n            if (letter == '/' && path) {\n                return '/'\n            }\n\n            return '%' + letter.charCodeAt(0).toString(16).toUpperCase()\n        })\n        .join('')\n}\n\n/**\n * Class holding URI encoding configuration\n */\nexport class URIEncodingConfig {\n    double: boolean\n    path: boolean\n\n    /**\n     *\n     * @param {boolean} double - should the URI be double encoded?\n     * @param {boolean} path - is the URI a path? If so, its forward\n     *     slashes won't be URIencoded.\n     */\n    constructor(double: boolean, path: boolean) {\n        this.double = double\n        this.path = path\n    }\n}\n\n/**\n * Compute the request time value as specified by the ISO8601\n * format: YYYYMMDD'T'HHMMSS'Z'\n *\n * @param  {number} timestamp\n * @return {string}\n */\nexport function toTime(timestamp: number): string {\n    return new Date(timestamp).toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n}\n/**\n * Computethe request date value in the format: YYYMMDD\n *\n * @param  {number} timestamp\n * @return {string}\n */\nexport function toDate(timestamp: number): string {\n    return toTime(timestamp).substring(0, 8)\n}\n\n/**\n * Parse a HTTP request URL's querystring into an object\n * containing its `key=value` pairs.\n *\n * @param  {string} qs\n * @return {object}\n */\nexport function parseQueryString(qs: string): Array<[string, string]> {\n    if (qs.length === 0) {\n        return []\n    }\n\n    return qs\n        .split('&')\n        .filter((e) => e)\n        .map((v: string): [string, string] => {\n            const parts = v.split('=', 2) as [string, string]\n            const key = decodeURIComponent(parts[0])\n            let value = decodeURIComponent(parts[1])\n            if (value === 'undefined') {\n                value = ''\n            }\n            return [key, value]\n        })\n        .sort((a: [string, string], b: [string, string]) => {\n            return a[0].localeCompare(b[0])\n        })\n}\n\nfunction isAlpha(c: string): boolean {\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')\n}\n\nfunction isNumeric(c: string): boolean {\n    return c >= '0' && c <= '9'\n}\n\n// FIXME: finish implementation when needed\n// See the following for more details:\n//   * https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n//   * https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n// export function signQueryString(\n// queryString,\n// requestTimestamp,\n// accessKeyID,\n// secretAccessKey,\n// region,\n// service,\n// ttl, // in seconds\n// headers,\n// doubleURIEncoding = true\n// ) {\n// const credential = [accessKeyID, toDate(requestTimestamp), region, service].join('/')\n//\n// const canonicalRequest = createCanonicalRequest(\n// method,\n// path,\n// queryString,\n// headers,\n// body,\n// doubleURIEncoding\n// )\n//\n// const derivedSigningKey = deriveSigningKey(secretAccessKey, requestTimestamp, region, service)\n//\n// const stringToSign = createStringToSign(\n// requestTimestamp,\n// region,\n// service,\n// sha256(canonicalRequest, 'hex')\n// )\n//\n// const signedHeaders = createSignedHeaders(headers)\n// const signature = calculateSignature(derivedSigningKey, stringToSign)\n//\n// return [\n// `X-Amz-Algorithm=${HashingAlgorithm}`,\n// `X-Amz-Credential=${crediental}`,\n// `X-Amz-Date=${toTime(requestTimestamp)}`,\n// `X-Amz-Expires=${ttl}`,\n// `X-Amz-SignedHeaders=${signedHeaders}`,\n// `X-Amz-Signature=${signature}`,\n//`X-Amz-Security-Token=`,  // TODO: optional\n// ].join('&')\n// }\n","import { HTTPScheme } from './http'\n\n/** Class holding an AWS connection information */\nexport class AWSConfig {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyID: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme} ['https']\n     */\n    scheme: HTTPScheme = 'https'\n\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string} ['amazonaws.com']\n     */\n    endpoint: string = 'amazonaws.com'\n\n    /**\n     * Create an AWSConfig.\n     *\n     * @param {AWSConfigOptions} options - configuration attributes to use when interacting with AWS' APIs\n     * @throws {InvalidArgumentException}\n     */\n    constructor(options: AWSConfigOptions) {\n        if (options.region === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS region; reason: should be a non empty string'\n            )\n        }\n\n        if (options.accessKeyId === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS access key ID; reason: should be a non empty string'\n            )\n        }\n\n        if (options.accessKeyId.length < 16 || options.accessKeyId.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${options.accessKeyId.length}`\n            )\n        }\n\n        if (options.secretAccessKey === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS secret access key; reason: should be a non empty string'\n            )\n        }\n\n        if (options.secretAccessKey.length < 16 || options.secretAccessKey.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: size should be between 16 and 128 characters, got ${options.secretAccessKey.length}`\n            )\n        }\n\n        this.region = options.region\n        this.accessKeyID = options.accessKeyId\n        this.secretAccessKey = options.secretAccessKey\n\n        if (options.sessionToken !== undefined) {\n            this.sessionToken = options.sessionToken\n        }\n\n        if (options.scheme !== undefined) {\n            this.scheme = options.scheme\n        }\n\n        if (options.endpoint !== undefined) {\n            this.endpoint = options.endpoint\n        }\n    }\n}\n\n/**\n * Interface representing AWSConfig options\n */\nexport interface AWSConfigOptions {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme}\n     */\n    scheme?: HTTPScheme\n\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string}\n     */\n    endpoint?: string\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n    constructor(message: string) {\n        super(message)\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/http\");","import { JSONObject } from 'k6'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { AWSClient, AWSRequest } from './client'\nimport { AWSError } from './error'\nimport { AWSConfig } from './config'\nimport { InvalidSignatureError, URIEncodingConfig } from './signature'\nimport { HTTPMethod, HTTPHeaders } from './http'\n\n/**\n * Class allowing to interact with Amazon AWS's Systems Manager service\n */\nexport class SystemsManagerClient extends AWSClient {\n    method: HTTPMethod\n    commonHeaders: HTTPHeaders\n\n    /**\n     * Create a SystemsManagerClient\n     * @param  {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        const URIencodingConfig = new URIEncodingConfig(true, false)\n        super(awsConfig, 'ssm', URIencodingConfig)\n\n        // All interactions with the Systems Manager service\n        // are made via the POST method.\n        this.method = 'POST'\n        this.commonHeaders = {\n            'Accept-Encoding': 'identity',\n            'Content-Type': 'application/x-amz-json-1.1',\n        }\n    }\n\n    /**\n     * Retrieves a parameter from Amazon Systems Manager\n     *\n     * @param {string} name - The ARN or name of the parameter to retrieve.\n     * @param {boolean} withDecryption - The ARN or name of the parameter to retrieve.\n     * @returns {Parameter} - returns the content of the fetched Parameter object.\n     * @throws {SystemsManagerServiceError}\n     * @throws {InvalidSignatureError}\n     */\n    getParameter(name: string, withDecryption: boolean = false): Parameter | undefined {\n        const body = JSON.stringify({ Name: name, WithDecryption: withDecryption })\n\n        // Ensure to include the desired 'Action' in the X-Amz-Target\n        // header field, as documented by the AWS API docs.\n        const signedRequest: AWSRequest = super.buildRequest(\n            this.method,\n            this.host,\n            '/',\n            '',\n            body,\n            {\n                ...this.commonHeaders,\n                'X-Amz-Target': `AmazonSSM.GetParameter`,\n            }\n        )\n\n        const res = http.request(this.method, signedRequest.url, body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error('GetParameter', res)\n        // a little confusing but need to unnest Parameter...\n        // TODO: make Parameter the root type with ParameterItem as a subtype\n        // TODO: test selector and source to be optional\n        return Parameter.fromJSON((res.json() as JSONObject).Parameter as JSONObject)\n    }\n\n    // TODO: operation should be an enum\n    _handle_error(operation: string, response: RefinedResponse<ResponseType | undefined>) {\n        const errorCode = response.error_code\n        if (errorCode === 0) {\n            return\n        }\n\n        const error = response.json() as JSONObject\n        if (errorCode >= 1400 && errorCode <= 1499) {\n            // In the event of certain errors, the message is not set.\n            // Also, note the inconsistency in casing...\n            const errorMessage: string =\n                (error.Message as string) || (error.message as string) || (error.__type as string)\n\n            // Handle specifically the case of an invalid signature\n            if (error.__type === 'InvalidSignatureException') {\n                throw new InvalidSignatureError(errorMessage, error.__type)\n            }\n\n            // Otherwise throw a standard service error\n            throw new SystemsManagerServiceError(errorMessage, error.__type as string, operation)\n        }\n\n        if (errorCode === 1500) {\n            throw new SystemsManagerServiceError(\n                'An error occured on the server side',\n                'InternalServiceError',\n                operation\n            )\n        }\n    }\n}\n\n/**\n * Class representing a Systems Manager's Parameter\n */\nexport class Parameter {\n    arn: string\n    dataType: string\n    lastModifiedDate: number\n    name: string\n    selector: string\n    sourceResult: string\n    type: string\n    value: string\n    version: number\n\n    /**\n     * Constructs a Systems Manager's Parameter\n     *\n     * @param  {string} arn - The Amazon Resource Name (ARN) of the parameter.\n     * @param  {string} dataType - The data type of the parameter, such as text or aws:ec2:image. The default is text.\n     * @param  {number} lastModifiedDate - Date the parameter was last changed or updated and the parameter version was created.\n     * @param  {string} name - The friendly name of the parameter.\n     * @param  {string} selector - Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats:\n     *  parameter_name:version\n     *  parameter_name:label\n     * @param  {string} sourceResult - Applies to parameters that reference information in other AWS services. SourceResult is the raw result or response from the source.\n     * @param  {string} type - The type of parameter. Valid values include the following: String, StringList, and SecureString.\n     * @param  {string} value - The parameter value.\n     * @param  {number} version - The parameter version.\n     */\n    constructor(\n        arn: string,\n        dataType: string,\n        lastModifiedDate: number,\n        name: string,\n        selector: string,\n        sourceResult: string,\n        type: string,\n        value: string,\n        version: number\n    ) {\n        this.arn = arn\n        this.dataType = dataType\n        this.lastModifiedDate = lastModifiedDate\n        this.name = name\n        this.selector = selector\n        this.sourceResult = sourceResult\n        this.type = type\n        this.value = value\n        this.version = version\n    }\n\n    /**\n     * Parses and constructs a Systems Manager's Parameter from the content\n     * of a JSON response returned by the AWS service\n     *\n     * @param  {Object} json - JSON object as returned and parsed from\n     *     the AWS service's API call.\n     * @returns {Parameter}\n     */\n    static fromJSON(json: JSONObject): Parameter {\n        return new Parameter(\n            json.ARN as string,\n            json.DataType as string,\n            json.LastModifiedDate as number,\n            json.Name as string,\n            json.Selector as string,\n            json.SourceResult as string,\n            json.Type as string,\n            json.Value as string,\n            json.Version as number\n        )\n    }\n}\n\nexport class SystemsManagerServiceError extends AWSError {\n    operation: string\n\n    /**\n     * Constructs a SystemsManagerServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: string) {\n        super(message, code)\n        this.name = 'SystemsManagerServiceError'\n        this.operation = operation\n    }\n}\n","import { HTTPMethod, HTTPHeaders } from './http'\nimport { AWSConfig } from './config'\nimport { signHeaders, URIEncodingConfig, toTime } from './signature'\n\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n    awsConfig: AWSConfig\n    serviceName: string\n    URIencodingConfig: URIEncodingConfig\n\n    /**\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     * @param  {string} serviceName - name of the service to target.\n     * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n     */\n    constructor(awsConfig: AWSConfig, serviceName: string, URIencodingConfig: URIEncodingConfig) {\n        this.awsConfig = awsConfig\n        this.serviceName = serviceName\n        this.URIencodingConfig = URIencodingConfig\n    }\n\n    buildRequest(\n        method: HTTPMethod,\n        host: string,\n        path: string,\n        queryString: string,\n        body: string | ArrayBuffer,\n        headers: HTTPHeaders\n    ): AWSRequest {\n        const requestTimestamp: number = Date.now()\n        const date: string = toTime(requestTimestamp)\n\n        headers['Host'] = host\n        headers['X-Amz-Date'] = date\n\n        headers = signHeaders(\n            // headers\n            headers,\n\n            // requestTimestamp\n            requestTimestamp,\n\n            // method\n            method,\n\n            // path\n            path,\n\n            // querystring\n            queryString,\n\n            // body\n            body,\n\n            // AWS configuration\n            this.awsConfig,\n\n            // AwS target service name\n            this.serviceName,\n\n            // doubleEncoding: S3 does single-encoding of the uri component\n            // pathURIEncoding: S3 manipulates object keys, and forward slashes\n            // shouldn't be URI encoded\n            this.URIencodingConfig\n        )\n\n        // '?' should not be part of the querystring when we sign the headers\n        path = path !== '' ? path : '/'\n        let url = `${this.awsConfig.scheme}://${host}${path}`\n        if (queryString !== '') {\n            url += `?${queryString}`\n        }\n\n        return { url: url, headers: headers }\n    }\n\n    /**\n     * Property computing the URL to send the requests to when interacting with\n     * the specific AWS service the child class implements the functionalities of.\n     */\n    get host() {\n        return `${this.serviceName}.${this.awsConfig.region}.${this.awsConfig.endpoint}`\n    }\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n    url: string\n    headers: HTTPHeaders\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","AWSError","message","code","name","xmlDocument","doc","parseHTML","find","text","Error","signHeaders","headers","requestTimestamp","method","path","queryString","body","awsConfig","service","URIencodingConfig","sessionToken","derivedSigningKey","secretAccessKey","time","region","kSecret","date","toDate","kDate","hmac","kRegion","kService","deriveSigningKey","canonicalRequest","uri","query","payload","httpRequestMethod","toUpperCase","canonicalURI","length","URIEncode","createCanonicalURI","canonicalQueryString","qs","split","filter","e","map","v","parts","decodeURIComponent","sort","b","localeCompare","parseQueryString","uriComponent","encodeURIComponent","join","createCanonicalQueryString","canonicalHeaders","constructor","entries","values","toLowerCase","trim","Array","isArray","replace","createCanonicalHeaders","signedHeaders","createSignedHeaders","requestPayload","UnsignedPayload","crypto","createCanonicalPayload","createCanonicalRequest","stringToSign","hashedCanonicalRequest","requestDateTime","toTime","credentialScope","createCredentialScope","HashingAlgorithm","createStringToSign","sha256","signature","calculateSignature","authorizationHeader","accessKeyID","InvalidSignatureError","TypeError","keys","letter","c","isNumeric","includes","charCodeAt","toString","URIEncodingConfig","double","this","timestamp","Date","toISOString","substring","AWSConfig","options","InvalidAWSConfigError","accessKeyId","undefined","scheme","endpoint","SystemsManagerClient","commonHeaders","withDecryption","JSON","stringify","Name","WithDecryption","signedRequest","host","res","http","url","_handle_error","Parameter","fromJSON","json","operation","response","errorCode","error_code","error","errorMessage","Message","__type","SystemsManagerServiceError","serviceName","now","arn","dataType","lastModifiedDate","selector","sourceResult","type","version","ARN","DataType","LastModifiedDate","Selector","SourceResult","Type","Value","Version"],"sourceRoot":""}